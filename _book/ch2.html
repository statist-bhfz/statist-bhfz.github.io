<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python</title>
  <meta name="description" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python." />
  <meta name="generator" content="bookdown 0.20 and GitBook 2.6.7" />

  <meta property="og:title" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python" />
  
  <meta name="twitter:description" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python." />
  

<meta name="author" content="Артем Груздев, Андрей Огурцов" />


<meta name="date" content="2020-07-31" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="ch1.html"/>
<link rel="next" href="ch3.html"/>
<script src="libs/header-attrs-2.3/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Вступление</a></li>
<li class="chapter" data-level="1" data-path="ch1.html"><a href="ch1.html"><i class="fa fa-check"></i><b>1</b> Введение в метод деревьев решений</a>
<ul>
<li class="chapter" data-level="1.1" data-path="ch1.html"><a href="ch1.html#ch1.1"><i class="fa fa-check"></i><b>1.1</b> Введение в методологию деревьев решений</a></li>
<li class="chapter" data-level="1.2" data-path="ch1.html"><a href="ch1.html#ch1.2"><i class="fa fa-check"></i><b>1.2</b> Краткий обзор методов деревьев решений CHAID и CART</a></li>
<li class="chapter" data-level="1.3" data-path="ch1.html"><a href="ch1.html#ch1.3"><i class="fa fa-check"></i><b>1.3</b> Преимущества и недостатки деревьев решений</a></li>
<li class="chapter" data-level="1.4" data-path="ch1.html"><a href="ch1.html#ch1.4"><i class="fa fa-check"></i><b>1.4</b> Задачи, выполняемые с помощью деревьев решений</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="ch2.html"><a href="ch2.html"><i class="fa fa-check"></i><b>2</b> Построение деревьев решений CHAID с помощью пакета R CHAID</a>
<ul>
<li class="chapter" data-level="2.1" data-path="ch2.html"><a href="ch2.html#ch2.1"><i class="fa fa-check"></i><b>2.1</b> Знакомство с методом CHAID</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="ch2.html"><a href="ch2.html#ch2.1.1"><i class="fa fa-check"></i><b>2.1.1</b> Описание алгоритма</a></li>
<li class="chapter" data-level="2.1.2" data-path="ch2.html"><a href="ch2.html#ch2.1.2"><i class="fa fa-check"></i><b>2.1.2</b> Немного о критерии хи-квадрат</a></li>
<li class="chapter" data-level="2.1.3" data-path="ch2.html"><a href="ch2.html#ch2.1.3"><i class="fa fa-check"></i><b>2.1.3</b> Немного об F-критерии</a></li>
<li class="chapter" data-level="2.1.4" data-path="ch2.html"><a href="ch2.html#ch2.1.4"><i class="fa fa-check"></i><b>2.1.4</b> Способы объединения категорий предикторов</a></li>
<li class="chapter" data-level="2.1.5" data-path="ch2.html"><a href="ch2.html#ch2.1.5"><i class="fa fa-check"></i><b>2.1.5</b> Поправка Бонферрони</a></li>
<li class="chapter" data-level="2.1.6" data-path="ch2.html"><a href="ch2.html#ch2.1.6"><i class="fa fa-check"></i><b>2.1.6</b> XCHAID</a></li>
<li class="chapter" data-level="2.1.7" data-path="ch2.html"><a href="ch2.html#ch2.1.7"><i class="fa fa-check"></i><b>2.1.7</b> Иллюстрация работы CHAID на конкретном примере</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="ch2.html"><a href="ch2.html#ch2.2"><i class="fa fa-check"></i><b>2.2</b> Предварительная подготовка данных перед построением модели дерева CHAID</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="ch2.html"><a href="ch2.html#ch2.2.1"><i class="fa fa-check"></i><b>2.2.1</b> Загрузка данных</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="ch3.html"><a href="ch3.html"><i class="fa fa-check"></i><b>3</b> Построение деревьев решений CART с помощью пакета R rpart</a>
<ul>
<li class="chapter" data-level="3.1" data-path="ch3.html"><a href="ch3.html#ch3.1"><i class="fa fa-check"></i><b>3.1</b> Знакомство с методом CART</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="ch3.html"><a href="ch3.html#ch3.1.1"><i class="fa fa-check"></i><b>3.1.1</b> Описание алгоритма</a></li>
<li class="chapter" data-level="3.1.2" data-path="ch3.html"><a href="ch3.html#ch3.1.2"><i class="fa fa-check"></i><b>3.1.2</b> Неоднородность</a></li>
<li class="chapter" data-level="3.1.3" data-path="ch3.html"><a href="ch3.html#ch3.1.3"><i class="fa fa-check"></i><b>3.1.3</b> Метод отсечения ветвей на основе меры стоимости-сложности с перекрестной проверкой</a></li>
<li class="chapter" data-level="3.1.4" data-path="ch3.html"><a href="ch3.html#ch3.1.4"><i class="fa fa-check"></i><b>3.1.4</b> Обработка пропущенных значений</a></li>
<li class="chapter" data-level="3.1.5" data-path="ch3.html"><a href="ch3.html#ch3.1.5"><i class="fa fa-check"></i><b>3.1.5</b> Иллюстрация работы метода CART на конкретных примерах</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Деревянные алгоритмы в R и Python</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="ch2" class="section level1" number="2" style="text-align: justify">
<h1><span class="header-section-number">2</span> Построение деревьев решений CHAID с помощью пакета R CHAID</h1>
<div id="ch2.1" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Знакомство с методом CHAID</h2>
<div id="ch2.1.1" class="section level3" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> Описание алгоритма</h3>
<p>Перед началом работы алгоритма CHAID необходимо преобразовать все имеющиеся количественные предикторы в порядковые переменные. Обычно их разбивают на 10 категорий одинакового объема.</p>
<p>Алгоритм приступает к построению дерева, итеративно применяя к каждому узлу, начиная с корневого, процедуры объединения категорий, расщепления узла и проверки правил остановки.</p>
<p><strong>Этап 1. Объединение категорий</strong></p>
<p>1. Для каждого предиктора с числом категорий больше двух<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> алгоритм ищет пару категорий с наименее значимыми различиями по зависимой переменной, т.е. пару категорий, для которых после применения соответствующего статистического критерия получено наибольшее p-значение. Выбор статистического критерия определяется типом шкалы зависимой переменной. Для номинальной зависимой переменной используется критерий хи-квадрат Пирсона. Алгоритм строит двухвходовую таблицу сопряженности с категориями предиктора в качестве строк и категориями зависимой переменной в качестве столбцов. Он проверяет нулевую гипотезу о том, что категории предиктора не отличаются друг от друга с точки зрения распределения категорий зависимой переменной. Для количественной зависимой переменной используется F-критерий. Алгоритм осуществляет однофакторный дисперсионный анализ и проверяет нулевую гипотезу о том, что средние значения зависимой переменной для различных категорий предиктора не различаются между собой.</p>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>Пакет R <code>CHAID</code> позволяет работать только с категориальной зависимой переменной. Возможность работы с количественной зависимой переменной реализована в процедуре <strong>Деревья классификации/CHAID</strong> проприетарного программного пакета IBM SPSS Statistics и питоновском пакете <code>CHAID</code>.</p>
<p>2. Найдя наибольшее p-значение для пары категорий, алгоритм сравнивает его с заданным уровнем значимости для объединения категорий.</p>
<p>Если p-значение:</p>
<ul>
<li><p>меньше или равно заданному уровню значимости для объединения категорий – алгоритм переходит к вычислению скорректированных p-значений для полученного набора категорий (шаг 3);</p></li>
<li><p>больше уровня значимости для объединения категорий – эта пара объединяется в отдельную составную категорию, в результате формируется новый набор категорий предиктора и процесс начинается заново с поиска пары категорий с наибольшим p-значением.</p></li>
</ul>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID уровень</code> значимости для объединения категорий можно задать c помощью параметра <code>alpha2</code> вспомогательной функции <code>chaid_control()</code>.</p>
<p>(Опциональный шаг) Если новая составная категория состоит из трех и более исходных категорий, алгоритм находит внутри этой составной категории наилучшее бинарное расщепление, которое дает наименьшее p-значение. Алгоритм выполняет бинарное расщепление, если его p-значение не превышает уровня значимости для разбиения объединенных категорий.</p>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID</code> уровень значимости для разбиения уже объединенных категорий можно настроить c помощью параметра <code>alpha3</code> вспомогательной функции <code>chaid_control()</code>.</p>
<p>3. Получив сформированный набор категорий предиктора, алгоритм для категориальной зависимой переменной вновь строит двухвходовую таблицу сопряженности с категориями предиктора в качестве строк и категориями зависимой переменной в качестве столбцов, а для количественной зависимой переменной вновь выполняет однофакторный дисперсионный анализ. В результате алгоритм вычисляет скорректированное p-значение критерия хи-квадрат или F-критерия как исходное p-значение, умноженное на поправку Бонферонни. Поправка Бонферрони представляет собой корректировку уровня значимости в зависимости от числа возможных способов, с помощью которых исходные категории предиктора могут быть объединены в итоговые категории.</p>
<p><strong>Этап 2. Расщепление узла</strong></p>
<p>После вычисления скорректированных p-значений для итоговых наборов категорий по всем предикторам алгоритм переходит к этапу расщепления узла.</p>
<p>1. На этапе расщепления алгоритм выбирает, какой предиктор обеспечит наилучшее разбиение узла. Для этого предиктор должен иметь наименьшее скорректированное p-значение (т.е. должен являться наиболее статистически значимым).</p>
<p>2. Найдя предиктор с наименьшим скорректированным p-значением, алгоритм сравнивает его с заданным уровнем значимости для расщепления.</p>
<p>Если p-значение:</p>
<ul>
<li><p>меньше или равно заданному уровню значимости для расщепления – алгоритм разбивает узел с использованием данного предиктора;</p></li>
<li><p>больше заданного уровня значимости для расщепления, то алгоритм не расщепляет узел и узел рассматривается как терминальный.</p></li>
</ul>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID</code> уровень значимости для расщепления узла можно настроить c помощью параметра <code>alpha4</code> вспомогательной функции <code>chaid_control()</code>.</p>
<p><strong>Этап 3. Остановка</strong></p>
<p>Алгоритм проверяет, нужно ли прекратить построение дерева, в соответствии со следующими правилами остановки:</p>
<ol style="list-style-type: decimal">
<li><p>Если узел стал однородным, то есть все наблюдения в узле имеют одинаковые значения зависимой переменной, узел не разбивается.</p></li>
<li><p>Если текущая глубина дерева достигает заданной пользователем максимальной глубины дерева, процесс построения дерева останавливается.</p></li>
<li><p>Если количество наблюдений в родительском узле меньше заданного пользователем минимума наблюдений в родительском узле, узел не разбивается.</p></li>
<li><p>Если минимальное абсолютное количество наблюдений в терминальном узле меньше заданного пользователем минимума наблюдений в терминальном узле, узел не разбивается.</p></li>
<li><p>Если минимальная относительная частота наблюдений в терминальном узле меньше заданной пользователем минимальной относительной частоты наблюдений в терминальном узле, узел не разбивается.</p></li>
</ol>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID</code> с помощью ряда параметров вспомогательной функции <code>chaid_control()</code> можно изменить некоторые вышеперечисленные правила остановки:</p>
<ul>
<li><p><code>minsplit</code> задает минимальное количество наблюдений в родительском узле перед расщеплением, по умолчанию 20;</p></li>
<li><p><code>minbucket</code> задает минимальное абсолютное количество наблюдений в терминальном узле, по умолчанию 7;</p></li>
<li><p><code>minprob</code> задает минимальную относительную частоту наблюдений в терминальном узле, по умолчанию 0.01;</p></li>
<li><p><code>maxheight</code> задает максимальную высоту или глубину дерева (количество уровней дерева, лежащих ниже корневого узла), по умолчанию равен -1, т.е. ограничение отсутствует.</p></li>
</ul>
</div>
<div id="ch2.1.2" class="section level3" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> Немного о критерии хи-квадрат</h3>
<p>Предположим, на этапе объединения алгоритм проверяет, различаются ли значимо две категории предиктора <em>Семейное положение</em> <em>“Холост”</em> и <em>“Женат”</em> по зависимой переменной <em>Отклик</em>. Нулевая гипотеза звучит так: категории предиктора не отличаются друг от друга с точки зрения распределения категорий зависимой переменной. Альтернативная гипотеза заключается в том, что категории предиктора все же отличаются друг от друга по зависимой переменной. Строится двухвходовая таблица сопряженности, где строки являются категориями предиктора <em>Семейное положение</em>, а столбцы – категориями зависимой переменной <em>Отклик</em>. Для каждой ячейки таблицы фиксируем наблюдаемую частоту. Затем для каждой ячейки фиксируем ожидаемую частоту согласно нулевой гипотезе. В итоге для каждой ячейки вычисляем квадрат разности между наблюдаемой и ожидаемой частотой, поделенный на ожидаемую частоту. Складываем результаты, вычисленные по каждой ячейке, и получаем значение хи-квадрат (<span class="math inline">\(\chi^{2}\)</span>). Процесс вычисления хи-квадрат проиллюстрирован на рис. 2.1.</p>
<p><img src="figures/2.1.PNG" /></p>
<p><em>Рис. 2.1. Процесс вычисления значения хи-квадрат</em></p>
<p><span class="math display">\[\chi^{2}=\sum\frac{(O-E)^2}{E},\]</span>
где</p>
<p><span class="math inline">\(O\)</span> – наблюдаемые частоты;</p>
<p><span class="math inline">\(E\)</span> – ожидаемые частоты.</p>
<p><span class="math display">\[\chi^{2}=\frac{(20-16,5)^2}{16,5} + \frac{(13-16,5)^2}{16,5} + \frac{(30-33,5)^2}{33,5} + \frac{(37-33,5)^2}{33,5}=2,216\]</span>
Статистика хи-квадрат подчиняется распределению хи-квадрат со степенями свободы <span class="math inline">\(df=(R–1)(C–1)\)</span>, где <span class="math inline">\(R\)</span> и <span class="math inline">\(C\)</span> – количество строк и столбцов в таблице сопряженности. В нашем случае количество степеней свободы будет равно <span class="math inline">\(df=(2–1)(2–1)=1\)</span>.</p>
<p>Чтобы выяснить, достаточно ли велико полученное значение хи-квадрат для отклонения нулевой гипотезы, вычисляем соответствующую ему p-значение. p-значение – это вероятность ошибки, заключающейся в отклонении нулевой гипотезы, когда она верна. Это вероятность того, что случайная величина, имеющая распределение хи-квадрат при условии верности нулевой гипотезы, примет значение, не меньшее, чем вычисленное значение хи-квадрат. Решение об отклонении нулевой гипотезы принимается в результате сравнения p-значения с определенным пороговым уровнем, который называют уровнем значимости (<span class="math inline">\(\alpha\)</span>). Обычно p-значение сравнивают с общепринятым стандартным уровнем значимости<span class="math inline">\(\alpha=0,05\)</span>. Если найденное p-значение меньше уровня значимости, нулевую гипотезу отклоняют, в противном случае у нас нет оснований отвергнуть нулевую гипотезу.</p>
<p>В нашем случае значение хи-квадрат 2,216 с одной степенью свободы соответствует р-значению 0,1366. Таким образом, вероятность того, что статистика хи-квадрат примет вычисленное значение 2,216 и выше, когда категории предиктора <em>Семейное положение</em> не отличаются друг от друга с точки зрения распределения категорий зависимой переменной <em>Отклик</em>, составляет 0,1366. Это превышает уровень значимости 0,05. У нас нет оснований отвергнуть нулевую гипотезу. Можно сделать вывод, что категории переменной <em>Семейное положение</em> действительно не отличаются друг от друга с точки зрения распределения неоткликнувшихся и откликнувшихся клиентов. Данные категории предиктора можно объединить.</p>
<p>Обратите внимание, фраза «нет оснований отклонить нулевую гипотезу» не тождественна фразе «принять нулевую гипотезу», которая является неверной. Нулевая гипотеза обычно имеет очень конкретную формулировку. Например, она может звучит так: нет разницы между средним значением выборки №1 и выборки №2. Если мы не можем отклонить нулевую гипотезу, значит ли это, что данные значения равны? Вовсе не обязательно. То, что нам не удалось найти статистически значимой разницы, совершенно не означает, что мы доказали равенство двух величин. Кроме того, результаты применения статистических критериев зависят от величины различий и от размера выборки, и одинаковые различия на выборках разного размера могут оказаться в одном случае незначимыми (например, если есть две выборки по 20 наблюдений), а в другом (когда наблюдений будет по 1000) – значимыми на том же уровне значимости. Таким образом, мощность статистического критерия (способность выявлять различия там, где они есть) зависит от объема выборки.</p>
<p>Важным практическим моментом в построении деревьев по методу CHAID является то, что по мере роста дерева в узлах остается все меньше и меньше наблюдений, и на определенном этапе мы теряем возможность провести очередное разделение просто в силу малого числа наблюдений в узле. Даже если такое деление могло бы улучшить качество модели на обучающей выборке, оно не будет произведено, если мы не сможем отклонить нулевую гипотезу на заданном уровне значимости; использование поправки Бонферрони только усугубляет эту ситуацию (см. ниже). Но это нельзя однозначно рассматривать как недостаток метода, поскольку описанная особенность является своего рода встроенной регуляризацией, которая может повысить обобщающую способность модели.</p>
</div>
<div id="ch2.1.3" class="section level3" number="2.1.3">
<h3><span class="header-section-number">2.1.3</span> Немного об F-критерии</h3>
<p>Предположим, на этапе объединения категорий алгоритм проверяет, различаются ли значимо категории предиктора <em>Семейное положение</em> <em>“Холост”</em> и <em>“Женат”</em> по количественной зависимой переменной <em>Доход</em>. Нулевая гипотеза будет звучат так: средние значения зависимой переменной в категориях предиктора или группах одинаковы. Чтобы проверить ее, нужно ответить на два вопроса: насколько сильно значения отклоняются от среднего значения зависимой переменной в группах и насколько сильно средние значения зависимой переменной в группах отличаются от среднего значения зависимой переменной перед разбиением на группы. Соответственно выполняется однофакторный дисперсионный анализ, в ходе которого подсчитывают внутригрупповую сумму квадратов отклонений и межгрупповую сумму квадратов отклонений и вычисляют F-критерий (критерий Фишера).</p>
<p>Сумма квадратов между группами (дочерними узлами) определяется по формуле:</p>
<p>Предположим, на этапе объединения категорий алгоритм проверяет, различаются ли значимо категории предиктора Семейное положение Холост и Женат по количественной зависимой переменной Доход. Нулевая гипотеза будет звучат так: средние значения зависимой переменной в категориях предиктора или группах одинаковы. Чтобы проверить ее, нужно ответить на два вопроса: насколько сильно значения отклоняются от среднего значения зависимой переменной в группах и насколько сильно средние значения зависимой переменной в группах отличаются от среднего значения зависимой переменной перед разбиением на группы. Соответственно выполняется однофакторный дисперсионный анализ, в ходе которого подсчитывают внутригрупповую сумму квадратов отклонений и межгрупповую сумму квадратов отклонений и вычисляют F-критерий (критерий Фишера).
Сумма квадратов между группами (дочерними узлами) определяется по формуле:</p>
<p><span class="math display">\[SS_{межгрупп}=\sum^{B}_{i=1}n_i(\bar{y}_{i.}-\bar{y}_{..})^2,\]</span></p>
<p>где</p>
<p><span class="math inline">\(\bar{y}_{i.}\)</span> – среднее значение зависимой переменной в <span class="math inline">\(i\)</span>-том дочернем узле;</p>
<p><span class="math inline">\(\bar{y}_{..}\)</span> – среднее значение зависимой переменной в родительском узле.</p>
<p>Сумма квадратов внутри групп (дочерних узлов) определяется по формуле:</p>
<p><span class="math display">\[SS_{внутригрупп}=\sum^{B}_{i=1}\sum^{n_i}_{j=1}n_i(y_{ij}-\bar{y}_{i.})^2,\]</span></p>
<p>где</p>
<p><span class="math inline">\(y_{ij}\)</span> – значение зависимой переменной для <span class="math inline">\(j\)</span>-ого наблюдения в <span class="math inline">\(i\)</span>-том дочернем узле;</p>
<p><span class="math inline">\(\bar{y}_{i.}\)</span> – среднее значение зависимой переменной в <span class="math inline">\(i\)</span>-том дочернем узле.</p>
<p>Общая сумма квадратов отклонений имеет вид</p>
<p><span class="math display">\[SS_{общая}=\sum^{B}_{i=1}\sum^{n_i}_{j=1}n_i(y_{ij}-\bar{y}_{..})^2\]</span></p>
<p>F-критерий – это отношение межгрупповой суммы квадратов отклонений к внутригрупповой:</p>
<p><span class="math display">\[F=frac_{S_{межгрупп}}{S_{внутригрупп}} \sim F(B-1, n-B)\]</span></p>
<p>Эта статистика подчиняется F-распределению с <span class="math inline">\(B – 1\)</span> и <span class="math inline">\(n – B\)</span> степенями свободы согласно нулевой гипотезе.</p>
<p>p-значение – это вероятность того, что случайная величина с распределением Фишера при условии верности нулевой гипотезы примет значение, не меньшее, чем фактическое значение статистики. Допустим, для нашего примера мы получили значение F-теста 15,943, соответствующее р-значению 0,000. Вероятность того, что F-статистика примет фактическое значение 15,943 и выше, когда средние значения зависимой переменной в категориях предиктора одинаковы, составляет &lt;0,001. Это меньше уровня значимости 0,05. Мы можем отклонить нулевую гипотезу и сделать вывод, что средние значения зависимой переменной в категориях предиктора неодинаковы, а межгрупповые различия являются более существенными, чем внутригрупповые. Данные категории предиктора объединять нельзя.</p>
</div>
<div id="ch2.1.4" class="section level3" number="2.1.4">
<h3><span class="header-section-number">2.1.4</span> Способы объединения категорий предикторов</h3>
<p>Способ объединения категорий предиктора зависит от шкалы его измерения.
В номинальных предикторах можно объединять любые категории, если они не различаются значимо по зависимой переменной. Таким образом, для номинальных переменных ограничения на объединение категорий не накладываются.</p>
<p>В порядковых предикторах две категории могут быть объединены, только если к ним могут быть присоединены промежуточные категории. Например, переменная, представляющая группы по уровню доходов, может рассматриваться как порядковая. Людей с доходом менее 2000$ имеет смысл объединять с теми, кто зарабатывает более 3000$, только если к вновь образовавшейся группе можно также отнести людей с доходом от 2000$ до 3000$.</p>
</div>
<div id="ch2.1.5" class="section level3" number="2.1.5">
<h3><span class="header-section-number">2.1.5</span> Поправка Бонферрони</h3>
<p>Осуществляя поиск незначимых категорий предиктора для объединения, CHAID выполняет большое количество статистических тестов для различных комбинаций категорий предиктора. Однако число таких комбинаций зависит от количества категорий, которое у каждой переменной разное.</p>
<p>Осуществляя поиск незначимых категорий предиктора для объединения, CHAID выполняет большое количество статистических тестов для различных комбинаций категорий предиктора. Однако число таких комбинаций зависит от количества категорий, которое у каждой переменной разное. Например, по одной переменной может оцениваться 2 варианта объединения, рассматриваться 2 таблицы сопряженности и выполняться 2 статистических теста, а по другой переменной – 6 вариантов объединения, 6 таблиц сопряженности и 6 статистических тестов. Вероятность того, что из 6 тестов хи-квадрат для второй переменной по крайней мере один из тестов дает ложное отклонение нулевой гипотезы составляет <span class="math inline">\(1-\prod^{6}_{i=1}(1-\alpha_i)\)</span>.</p>
<p>Групповая вероятность ошибки намного больше индивидуальной вероятности ошибки <span class="math inline">\(\alpha_i\)</span>. Например, если индивидуальная вероятность ошибки (<span class="math inline">\(\alpha_i\)</span>) по каждому тесту равна 0,05, то групповая вероятность ошибки составит <span class="math inline">\(1–0,956 = 0,265\)</span>. Таким образом, при осуществлении множественных проверок гипотез при помощи критерия хи-квадрат (одна проверка на каждое возможное объединение), р-значения недооценивают риск отклонения нулевой гипотезы, когда она верна. Эти рассуждения справедливы и для других статистических критериев. Например, вы можете сделать ошибочный вывод, что заемщики с разными профессиями отличаются по кредитоспособности, тогда как они на самом деле не отличаются.</p>
<p>Если мы хотим, чтобы групповая вероятность ошибки при этом не превышала определенный уровень значимости <span class="math inline">\(\alpha\)</span> (например, 0,05), то, согласно методу Бонферрони, мы должны умножить каждое полученное p-значение на <span class="math inline">\(m\)</span> – количество возможных вариантов объединения с исходных категорий предиктора в <span class="math inline">\(g\)</span> итоговых категорий, получить скорректированное p-значение и сравнить его с уровнем значимости <span class="math inline">\(\alpha\)</span>. Для номинального предиктора множитель <span class="math inline">\(m\)</span> определяется числом Стирлинга второго рода:</p>
<p><span class="math display">\[m=S(c, g) = \sum^{g-1}_{i=1}\frac{(-1)^i(g-i)^c}{i!(g-i)!}\]</span></p>
<p>На рис. 2.2 приводится таблица значений чисел Стирлинга при <span class="math inline">\(0≤c\)</span>, <span class="math inline">\(g≤9\)</span>.</p>
<p><img src="figures/2.2.PNG" /></p>
<p><em>Риc. 2.2. Таблица значений чисел Стерлинга при <span class="math inline">\(0≤c\)</span>, <span class="math inline">\(g≤9\)</span></em></p>
<p>Для порядкового предиктора множитель <span class="math inline">\(m\)</span> определяется как</p>
<p><span class="math display">\[m=\begin{pmatrix}c-1 \\g-1\end{pmatrix}=\frac{(c-1)!}{(g-1)!(c-g)!}\]</span>
Допустим, у нас есть три предиктора. Первый – номинальный предиктор <em>Сlass</em> с 8 категориями. Второй – номинальный предиктор <em>Type</em> с 5 категориями. Третий – порядковый предиктор <em>Incomecat</em> c 4 категориями. По завершении этапа объединения <em>Сlass</em> был преобразован в предиктор с тремя итоговыми категориями, и для него было вычислено p-значение 0,00001; <em>Type</em> был преобразован в предиктор с двумя итоговыми категориями, и для него было вычислено p-значение 0,009; <em>Incomecat</em> был преобразован в предиктор с тремя итоговыми категориями и получил p-значение 0,003. Множитель для предиктора <em>Class</em> равен <span class="math inline">\(m=S(8, 3)=\frac{1}{6}(3^8-3\times2^8+3)=966\)</span>. Таким образом, наше p-значение 0,00001 умножается на 966, и мы получаем скорректированное p-значение 0,00966. Множитель для предиктора <em>Type</em> равен <span class="math inline">\(m=S(5, 2)=2^4-1=15\)</span>. Наше p-значение 0,009 умножается на 15, и мы получаем скорректированное p-значение 0,135. Множитель для предиктора <em>Incomecat</em> равен <span class="math inline">\(m=\frac{(4-1)!}{(3-1)!(4-3)!}=\frac{3!}{2!\times1!}=\frac{6}{2}=3\)</span>. p-значение 0,003 умножается на 3, и мы получаем скорректированное p-значение 0,009. Для разбиения узла выбирается предиктор <em>Incomecat</em>, который имеет наименьшее скорректированное p-значение 0,009.</p>
<p><img src="figures/2.3.PNG" /></p>
<p><em>Риc. 2.3. Количество возможных разбиений переменной из 4 категорий на 2, 3, 4 группы</em></p>
</div>
<div id="ch2.1.6" class="section level3" number="2.1.6">
<h3><span class="header-section-number">2.1.6</span> XCHAID</h3>
<p>В 1991 году Дэвид Биггс, Барри Де Вилль и Эд Суен предложили модификацию метода CHAID – XCHAID (от Exhaustive CHAID – исчерпывающий CHAID). Он был разработан для устранения недостатка CHAID – ограниченного набора расщеплений для предиктора.</p>
<p>Алгоритм XCHAID приступает к построению дерева, итеративно применяя к каждому узлу, начиная с корневого, процедуры объединения категорий, расщепления узла и проверки правил остановки. Этапы расщепления и остановки в XCHAID аналогичны этапам расщепления и остановки в CHAID. Однако на этапе объединения категорий используется процедура более тщательного поиска категорий: пары категорий продолжают сравниваться и объединяться до тех пор, пока не останется одна пара категорий (напомним, что обычный CHAID прекращает объединение категорий, когда обнаруживает, что все оставшиеся категории статистически значимо различаются между собой). Таким образом, XCHAID позволяет найти наилучшее расщепление для каждого предиктора и затем выбрать, какой предиктор нужно расщепить. Вместе с тем, поскольку объединение категорий осуществляется более тщательно, чем в методе CHAID, XCHAID требует большего времени вычислений.</p>
<p><strong>Объединение категорий</strong></p>
<ol style="list-style-type: decimal">
<li><p>Для каждого предиктора с числом категорий больше двух алгоритм ищет пару категорий с наименее значимыми различиями по зависимой переменной. Для категориальной зависимой переменной используется критерий хи-квадрат Пирсона. Для количественной зависимой переменной может использоваться F-критерий.</p></li>
<li><p>Найдя пару с наибольшим p-значением, алгоритм объединяет ее в отдельную составную категорию.</p></li>
<li><p>Для нового набора категорий предиктора алгоритм вычисляет p-значение. Алгоритм запоминает p-значение и соответствующий набор категорий.</p></li>
<li><p>Алгоритм повторяет шаги 1, 2, 3 до тех пор, пока не останутся две категории. Затем среди всех наборов категорий предиктора алгоритм находит набор, у которого p-значение на шаге 3 является наименьшим.</p></li>
<li><p>Алгоритм вычисляет скорректированное p-значение для выбранного набора категорий.</p></li>
</ol>
<p><strong>Расщепление узла</strong></p>
<p>После вычисления скорректированных p-значений для итоговых наборов категорий по всем предикторам алгоритм переходит к этапу расщепления узла.</p>
<ol style="list-style-type: decimal">
<li><p>На этапе расщепления алгоритм выбирает, какой предиктор обеспечит наилучшее разбиение узла, то есть имеет наименьшее скорректированное p-значение (наиболее статистически значимый).</p></li>
<li><p>Найдя предиктор с наименьшим скорректированным p-значением, алгоритм сравнивает его с заданным уровнем значимости для расщепления.</p></li>
</ol>
<p>Если p-значение:</p>
<ul>
<li><p>меньше или равно заданному уровню значимости для расщепления – алгоритм разбивает узел с использованием данного предиктора;</p></li>
<li><p>больше заданного уровня значимости для расщепления, то алгоритм не расщепляет узел и узел рассматривается как терминальный.</p></li>
</ul>
<p><strong>Остановка</strong></p>
<p>Алгоритм проверяет, нужно ли прекратить построение дерева, в соответствии со следующими правилами остановки.</p>
<ol style="list-style-type: decimal">
<li><p>Если узел стал однородным, то есть все наблюдения в узле имеют одинаковые значения зависимой переменной, узел не разбивается.</p></li>
<li><p>Если текущая глубина дерева достигает заданной пользователем максимальной глубины дерева, процесс построения дерева останавливается.</p></li>
<li><p>Если количество наблюдений в родительском узле меньше заданного пользователем минимума наблюдений в родительском узле, узел не разбивается.</p></li>
<li><p>Если минимальное абсолютное количество наблюдений в терминальном узле меньше заданного пользователем минимума наблюдений в терминальном узле, узел не разбивается.</p></li>
<li><p>Если минимальная относительная частота наблюдений в терминальном узле меньше заданной пользователем минимальной относительной частоты наблюдений в терминальном узле, узел не разбивается.</p></li>
</ol>
<p>На практике метод XCHAID строит модель с одинаковой или чуть лучшей дискриминирующей способностью, чем метод CHAID, однако эта разница, как правило, не является статистически значимой. Если учесть, что при одинаковом качестве моделей времени на подгонку в случае использования метода XCHAID требуется больше (особенно это актуально при работе с большими выборками), данный метод используется редко.</p>
</div>
<div id="ch2.1.7" class="section level3" number="2.1.7">
<h3><span class="header-section-number">2.1.7</span> Иллюстрация работы CHAID на конкретном примере</h3>
<p>Предположим, есть данные по клиентам микрофинансовой организации и известно, выплатили они займ или нет (категориальная зависимая переменная <em>Просрочка</em>). В качестве потенциальных предикторов фигурируют четыре переменных: <em>Доход</em>, <em>Возраст</em>, <em>Сфера занятости</em>, <em>Пол</em>. Переменные <em>Пол</em> и <em>Сфера занятости</em> являются номинальными, переменные <em>Доход</em> и <em>Возраст</em> – порядковыми. Переменная <em>Сфера занятости</em> принимает значения <em>“Работает по найму”</em>, <em>“Свое дело”</em>, <em>“Учится или студент”</em>, <em>“Пенсионер”</em>. Переменная <em>Доход</em> принимает значения <em>“Менее 10 тыс. рублей”</em>, <em>“От 10 до 25 тыс. рублей”</em>, <em>“От 26 до 40 тыс. рублей”</em>, <em>“Более 40 тыс. рублей”</em>. Переменная <em>Пол</em> принимает значения <em>“Женщина”</em> и <em>Мужчина</em>. Переменная <em>Возраст</em> принимает значения <em>“&lt;24”</em>, <em>“24-26”</em>, <em>“27-28”</em>, <em>“29-31”</em>, <em>“32-33”</em>, <em>“34-35”</em>, <em>“36-38”</em>, <em>“39-41”</em>, <em>“42-46”</em> и <em>“&gt;46”</em>. Необходимо выяснить, какие группы клиентов с большей вероятностью выйдут в просрочку, чтобы сосредоточить внимание на них. Схематично наши исходные данные представлены на рис. 2.4.</p>
<p><img src="figures/2.4.PNG" /></p>
<p><em>Риc. 2.4. Исходные данные перед началом работы CHAID</em></p>
<p>Что же делает CHAID, когда мы запускаем его? По каждому предиктору CHAID берет пару категорий, сравнивает, различаются ли они по зависимой переменной, и объединяет их, если они не показывают этого различия (дают p-значение больше заданного уровня значимости для объединения).</p>
<p>В нашем случае по порядковому предиктору <em>Доход</em> CHAID сравнивает категорию <em>“Менее 10 тыс. рублей”</em> с категорией <em>“От 10 до 25 тыс. рублей”</em>, затем категорию <em>“От 10 до 25 тыс. рублей”</em> с категорией <em>“От 26 до 40 тыс. рублей”</em>, затем категорию <em>“От 26 до 40 тыс. рублей”</em> с категорией "<em>Более 40 тыс. рублей“<em>. Еще раз обратите внимание, что в порядковом предикторе несмежные категории (например, категория </em>”Менее 10 тыс. рублей"</em> и категория <em>“Более 40 тыс. рублей”</em>) сравниваться и объединяться не могут. Допустим, категории предиктора <em>Доход</em> <em>“Менее 10 тыс. рублей”</em> и <em>“От 10 до 25 тыс. рублей”</em> значимо не различаются по кредитоспособности (в обоих категориях наблюдается высокая доля «плохих» заемщиков), имеют наибольшее p-значение. Тогда CHAID объединяет их и формирует новый набор категорий (объединенная категория <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>, категория <em>“От 26 до 40 тыс. рублей”</em>, категория <em>“Более 40 тыс. рублей”</em>) и снова начинает процесс сравнения. Процесс объединения категорий остановится, когда все оставшиеся категории предиктора будут различаться на заданном уровне значимости для объединения. Сформировав новый набор категорий по предиктору <em>Доход</em>, алгоритм начинает аналогичным образом формировать набор категорий для порядкового предиктора <em>Возраст</em>, опять же сравнивая и объединяя только смежные категории. Затем алгоритм формирует набор категорий для номинального предиктора <em>Сфера занятости</em>. Здесь уже CHAID может сравнивать и объединять любые категории переменной. Затем переходит к предиктору <em>Пол</em>. Здесь категории предиктора Пол не могут быть объединены, поскольку у этой переменной только два уровня. Процесс сравнения и объединения категорий по каждому предиктору показан на рис. 2.5.</p>
<p><img src="figures/2.5.PNG" /></p>
<p><em>Риc. 2.5. Объединение категорий предикторов</em></p>
<p>В итоге получаем преобразованные предикторы <em>Доход</em> (допустим, набор из 3 категорий: объединенная категория <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>, категория <em>“От 26 до 40 тыс. рублей”</em>, категория <em>“Более 40 тыс. рублей”</em>), <em>Сфера занятости</em> (набор из 3 категорий: объединенная категория <em>“Работает по найму/Свое дело”</em>, категория <em>“Учится или студент”</em>, категория <em>“Пенсионер”</em>), <em>Возраст</em> (набор из 3 категорий: объединенная категория <em>“Менее 29 лет”</em>, объединенная категория <em>“От 29 до 46 лет”</em>, категория <em>“Старше 46 лет”</em>) и предиктор <em>Пол</em> (категория <em>“Женщины”</em> и категория <em>“Мужчины”</em>).</p>
<p>Завершив этап объединения, CHAID переходит к этапу разбиения узла (рис. 2.6). Здесь происходит вычисление p-значений для итоговых наборов категорий, затем p-значения корректируются с помощью поправки Бонферрони, чтобы учесть количество сравнений категорий по каждому предиктору.</p>
<p><img src="figures/2.6.PNG" /></p>
<p><em>Риc. 2.6. Выбор предиктора для разбиения узла</em></p>
<p>Например, лучшим предиктором объявлена переменная <em>Доход</em> (имеет наименьшее скорректированное p-значение, не превышающее заданный уровень значимости для разбиения узла). Тогда CHAID обращается к первой новой группе (например, объединенной категории <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>) и снова повторяет вышеописанные шаги, ищет наименее различающиеся категории для объединения и выбирает наиболее значимый предиктор для разбиения. Предположим, что для рассматриваемой группы таким предиктором стал <em>Пол</em>. Тогда CHAID разделяет группу <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em> по переменной <em>Пол</em>. Затем он исследует каждую из оставшихся групп, образованную переменной <em>Доход</em> (категории <em>“От 26 до 40 тыс. рублей”</em>, <em>“Более 40 тыс. рублей”</em>), снова по каждой группе проверяет категории предикторов на объединение и разбивает узел с помощью предиктора, который наиболее значимо связан с зависимой переменной для этой группы. Затем CHAID опускается на следующий уровень дерева и берет первую группу предиктора <em>Пол</em> <em>“Женщины”</em> внутри группы <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>, снова исследует категории и выясняет, есть ли среди предикторов значимо влияющие на зависимую переменную. Если таких предикторов для группы <em>“Женщины”</em> внутри группы <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em> не оказывается или выполняется условие остановки, то CHAID объявляет эту группу терминальным узлом и переходит к аналогичному исследованию группы <em>“Мужчины”</em> внутри группы <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>.</p>
<p>Таким способом, уровень за уровнем, CHAID систематически разделяет данные на группы (называемые узлами), показывающие значимые различия по отношению к зависимой переменной. Результаты этого процесса представляются в форме дерева, в котором ветвление происходит по мере деления на группы. Взглянув на построенное дерево (рис. 2.7), мы можем с уверенностью ответить на ряд вопросов. Какие из предикторов взаимосвязаны с переменной дефолта, помогают предсказать ее? Какие комбинации категорий этих предикторов дают наибольший процент попадания в интересующую категорию зависимой переменной? Они представляют собой целевые группы, на которых нужно сосредоточить внимание. В следующих разделах будет подробно рассказано, как строить и интерпретировать дерево решений CHAID в пакете R <code>CHAID</code>.</p>
<p><img src="figures/2.7.PNG" /></p>
<p><em>Риc. 2.7. Итоговое дерево CHAID</em></p>
</div>
</div>
<div id="ch2.2" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Предварительная подготовка данных перед построением модели дерева CHAID</h2>
<div id="ch2.2.1" class="section level3" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> Загрузка данных</h3>
<p>Данные, которыми мы воспользуемся для построения дерева классификации CHAID, записаны в файле <em>Churn.csv</em>. Исходная выборка содержит записи о 4431 клиенте, классифицированном на два класса: 0 — оттока нет (2496 клиентов) и 1 — отток есть (1935 клиентов). По каждому наблюдению (клиенту) фиксируются следующие переменные (характеристики):</p>
<ul>
<li><p>порядковый предиктор <em>Длительность междугородних звонков в минутах</em> [<code>longdist</code>];</p></li>
<li><p>порядковый предиктор <em>Длительность местных звонков в минутах</em> [<code>local</code>];</p></li>
<li><p>номинальный предиктор <em>Наличие скидки на междугородние звонки</em> [<code>int_disc</code>];</p></li>
<li><p>номинальный предиктор <em>Тип местных звонков</em> [<code>billtype</code>];</p></li>
<li><p>номинальный предиктор <em>Способ оплаты</em> [<code>pay</code>];</p></li>
<li><p>номинальный предиктор <em>Пол</em> [<code>gender</code>];</p></li>
<li><p>номинальный предиктор <em>Семейное положение</em> [<code>marital</code>];</p></li>
<li><p>количественный предиктор <em>Доход</em> [<code>income</code>];</p></li>
<li><p>порядковый предиктор <em>Возрастная категория</em> [<code>agecat</code>];</p></li>
<li><p>номинальная зависимая переменная <em>Наличие оттока</em> [<code>churn</code>].</p></li>
</ul>
<p>Необходимо разработать модель оттока, с помощью которой предполагается классифицировать новых клиентов на лояльных и склонных к уходу.</p>
<p>Запустим R. Для работы нам потребуются следующие пакеты:</p>
<ul>
<li><p><code>dplyr</code>;</p></li>
<li><p><code>Hmisc</code>;</p></li>
<li><p><code>stringr</code>;</p></li>
<li><p><code>car</code>;</p></li>
<li><p><code>imputeMissings</code>;</p></li>
<li><p><code>lsr</code>;</p></li>
<li><p><code>CHAID</code>;</p></li>
<li><p><code>pROC</code>;</p></li>
<li><p><code>precrec</code>;</p></li>
<li><p><code>xlsx</code>.</p></li>
</ul>
<p>Давайте установим их с помощью функции <code>install.packages()</code>. Если вы используете консольную версию R, вам будет предложено выбрать постоянный CRAN-репозиторий, из которого будут устанавливаться пакеты.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="ch2.html#cb1-1"></a><span class="kw">install.packages</span>(<span class="st">&quot;data.table&quot;</span>)</span>
<span id="cb1-2"><a href="ch2.html#cb1-2"></a><span class="kw">install.packages</span>(<span class="st">&quot;Hmisc&quot;</span>)</span>
<span id="cb1-3"><a href="ch2.html#cb1-3"></a><span class="kw">install.packages</span>(<span class="st">&quot;stringr&quot;</span>)</span>
<span id="cb1-4"><a href="ch2.html#cb1-4"></a><span class="kw">install.packages</span>(<span class="st">&quot;car&quot;</span>)</span>
<span id="cb1-5"><a href="ch2.html#cb1-5"></a><span class="kw">install.packages</span>(<span class="st">&quot;imputeMissings&quot;</span>)</span>
<span id="cb1-6"><a href="ch2.html#cb1-6"></a><span class="kw">install.packages</span>(<span class="st">&quot;lsr&quot;</span>)</span>
<span id="cb1-7"><a href="ch2.html#cb1-7"></a><span class="kw">install.packages</span>(<span class="st">&quot;CHAID&quot;</span>, <span class="dt">repos =</span> <span class="st">&quot;http://R-Forge.R-project.org&quot;</span>)</span>
<span id="cb1-8"><a href="ch2.html#cb1-8"></a><span class="kw">install.packages</span>(<span class="st">&quot;pROC&quot;</span>)</span>
<span id="cb1-9"><a href="ch2.html#cb1-9"></a><span class="kw">install.packages</span>(<span class="st">&quot;precrec&quot;</span>)</span>
<span id="cb1-10"><a href="ch2.html#cb1-10"></a><span class="kw">install.packages</span>(<span class="st">&quot;xlsx&quot;</span>)</span></code></pre></div>
<p>Иногда при установке пакетов появляется ошибка: *dependencies название_пакета are not available for package название_ <em>устанавливаемого</em> _пакета*. Это говорит о том, что перед установкой основного пакета вы должны установить требуемые пакеты-зависимости.</p>
<p>После установки пакетов их можно загрузить для работы с помощью функции <code>library()</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="ch2.html#cb2-1"></a><span class="kw">library</span>(data.table)</span></code></pre></div>
<pre><code>## data.table 1.13.0 using 4 threads (see ?getDTthreads).  Latest news: r-datatable.com</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="ch2.html#cb4-1"></a><span class="kw">library</span>(Hmisc)</span></code></pre></div>
<pre><code>## Loading required package: lattice</code></pre>
<pre><code>## Loading required package: survival</code></pre>
<pre><code>## Loading required package: Formula</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<pre><code>## Want to understand how all the pieces fit together? Read R for Data Science:
## https://r4ds.had.co.nz/</code></pre>
<pre><code>## 
## Attaching package: &#39;Hmisc&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     format.pval, units</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="ch2.html#cb12-1"></a><span class="kw">library</span>(stringr)</span>
<span id="cb12-2"><a href="ch2.html#cb12-2"></a><span class="kw">library</span>(car)</span></code></pre></div>
<pre><code>## Loading required package: carData</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="ch2.html#cb14-1"></a><span class="kw">library</span>(imputeMissings)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;imputeMissings&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:Hmisc&#39;:
## 
##     impute</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="ch2.html#cb17-1"></a><span class="kw">library</span>(lsr)</span>
<span id="cb17-2"><a href="ch2.html#cb17-2"></a><span class="kw">library</span>(CHAID)</span></code></pre></div>
<pre><code>## Loading required package: partykit</code></pre>
<pre><code>## Loading required package: grid</code></pre>
<pre><code>## Loading required package: libcoin</code></pre>
<pre><code>## Loading required package: mvtnorm</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="ch2.html#cb22-1"></a><span class="kw">library</span>(pROC)</span></code></pre></div>
<pre><code>## Type &#39;citation(&quot;pROC&quot;)&#39; for a citation.</code></pre>
<pre><code>## 
## Attaching package: &#39;pROC&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     cov, smooth, var</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="ch2.html#cb26-1"></a><span class="kw">library</span>(precrec)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;precrec&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:pROC&#39;:
## 
##     auc</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="ch2.html#cb29-1"></a><span class="kw">library</span>(readxl)</span></code></pre></div>
<p>При помощи функции <code>data.table::fread()</code> загрузим файл <em>Churn.csv</em> в таблицу данных <code>dt</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="ch2.html#cb30-1"></a>dt &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;data/Churn.csv&quot;</span>, <span class="dt">na.strings =</span> <span class="st">&quot;&quot;</span>)</span></code></pre></div>
</div>
</div>
</div>

<div class="footnotes">
<hr />
<ol start="6">
<li id="fn6"><p>Если предиктор имеет одну категорию, он исключается из анализа. Если предиктор имеет две категории, происходит переход к шагу 3.<a href="ch2.html#fnref6" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="ch1.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="ch3.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
