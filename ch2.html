<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python</title>
  <meta name="description" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python." />
  <meta name="generator" content="bookdown 0.20 and GitBook 2.6.7" />

  <meta property="og:title" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python" />
  
  <meta name="twitter:description" content="2 Построение деревьев решений CHAID с помощью пакета R CHAID | Деревянные алгоритмы в R и Python." />
  

<meta name="author" content="Артем Груздев, Андрей Огурцов" />


<meta name="date" content="2020-08-01" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="ch1.html"/>
<link rel="next" href="ch3.html"/>
<script src="libs/header-attrs-2.3/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Вступление</a></li>
<li class="chapter" data-level="1" data-path="ch1.html"><a href="ch1.html"><i class="fa fa-check"></i><b>1</b> Введение в метод деревьев решений</a>
<ul>
<li class="chapter" data-level="1.1" data-path="ch1.html"><a href="ch1.html#ch1.1"><i class="fa fa-check"></i><b>1.1</b> Введение в методологию деревьев решений</a></li>
<li class="chapter" data-level="1.2" data-path="ch1.html"><a href="ch1.html#ch1.2"><i class="fa fa-check"></i><b>1.2</b> Краткий обзор методов деревьев решений CHAID и CART</a></li>
<li class="chapter" data-level="1.3" data-path="ch1.html"><a href="ch1.html#ch1.3"><i class="fa fa-check"></i><b>1.3</b> Преимущества и недостатки деревьев решений</a></li>
<li class="chapter" data-level="1.4" data-path="ch1.html"><a href="ch1.html#ch1.4"><i class="fa fa-check"></i><b>1.4</b> Задачи, выполняемые с помощью деревьев решений</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="ch2.html"><a href="ch2.html"><i class="fa fa-check"></i><b>2</b> Построение деревьев решений CHAID с помощью пакета R CHAID</a>
<ul>
<li class="chapter" data-level="2.1" data-path="ch2.html"><a href="ch2.html#ch2.1"><i class="fa fa-check"></i><b>2.1</b> Знакомство с методом CHAID</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="ch2.html"><a href="ch2.html#ch2.1.1"><i class="fa fa-check"></i><b>2.1.1</b> Описание алгоритма</a></li>
<li class="chapter" data-level="2.1.2" data-path="ch2.html"><a href="ch2.html#ch2.1.2"><i class="fa fa-check"></i><b>2.1.2</b> Немного о критерии хи-квадрат</a></li>
<li class="chapter" data-level="2.1.3" data-path="ch2.html"><a href="ch2.html#ch2.1.3"><i class="fa fa-check"></i><b>2.1.3</b> Немного об F-критерии</a></li>
<li class="chapter" data-level="2.1.4" data-path="ch2.html"><a href="ch2.html#ch2.1.4"><i class="fa fa-check"></i><b>2.1.4</b> Способы объединения категорий предикторов</a></li>
<li class="chapter" data-level="2.1.5" data-path="ch2.html"><a href="ch2.html#ch2.1.5"><i class="fa fa-check"></i><b>2.1.5</b> Поправка Бонферрони</a></li>
<li class="chapter" data-level="2.1.6" data-path="ch2.html"><a href="ch2.html#ch2.1.6"><i class="fa fa-check"></i><b>2.1.6</b> XCHAID</a></li>
<li class="chapter" data-level="2.1.7" data-path="ch2.html"><a href="ch2.html#ch2.1.7"><i class="fa fa-check"></i><b>2.1.7</b> Иллюстрация работы CHAID на конкретном примере</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="ch2.html"><a href="ch2.html#ch2.2"><i class="fa fa-check"></i><b>2.2</b> Предварительная подготовка данных перед построением модели дерева CHAID</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="ch2.html"><a href="ch2.html#ch2.2.1"><i class="fa fa-check"></i><b>2.2.1</b> Загрузка данных</a></li>
<li class="chapter" data-level="2.2.2" data-path="ch2.html"><a href="ch2.html#ch2.2.2"><i class="fa fa-check"></i><b>2.2.2</b> Фиксация пустых строковых значений как пропусков</a></li>
<li class="chapter" data-level="2.2.3" data-path="ch2.html"><a href="ch2.html#ch2.2.3"><i class="fa fa-check"></i><b>2.2.3</b> Вывод подробной информации о переменных</a></li>
<li class="chapter" data-level="2.2.4" data-path="ch2.html"><a href="ch2.html#ch2.2.4"><i class="fa fa-check"></i><b>2.2.4</b> Нормализация строковых значений</a></li>
<li class="chapter" data-level="2.2.5" data-path="ch2.html"><a href="ch2.html#ch2.2.5"><i class="fa fa-check"></i><b>2.2.5</b> Обработка дублирующихся наблюдений</a></li>
<li class="chapter" data-level="2.2.6" data-path="ch2.html"><a href="ch2.html#ch2.2.6"><i class="fa fa-check"></i><b>2.2.6</b> Изменение типов переменных</a></li>
<li class="chapter" data-level="2.2.7" data-path="ch2.html"><a href="ch2.html#ch2.2.7"><i class="fa fa-check"></i><b>2.2.7</b> Обработка редких категорий</a></li>
<li class="chapter" data-level="2.2.8" data-path="ch2.html"><a href="ch2.html#ch2.2.8"><i class="fa fa-check"></i><b>2.2.8</b> Однократное случайное разбиение набора данных на обучающую и контрольную выборки для проверки модели</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="ch3.html"><a href="ch3.html"><i class="fa fa-check"></i><b>3</b> Построение деревьев решений CART с помощью пакета R rpart</a>
<ul>
<li class="chapter" data-level="3.1" data-path="ch3.html"><a href="ch3.html#ch3.1"><i class="fa fa-check"></i><b>3.1</b> Знакомство с методом CART</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="ch3.html"><a href="ch3.html#ch3.1.1"><i class="fa fa-check"></i><b>3.1.1</b> Описание алгоритма</a></li>
<li class="chapter" data-level="3.1.2" data-path="ch3.html"><a href="ch3.html#ch3.1.2"><i class="fa fa-check"></i><b>3.1.2</b> Неоднородность</a></li>
<li class="chapter" data-level="3.1.3" data-path="ch3.html"><a href="ch3.html#ch3.1.3"><i class="fa fa-check"></i><b>3.1.3</b> Метод отсечения ветвей на основе меры стоимости-сложности с перекрестной проверкой</a></li>
<li class="chapter" data-level="3.1.4" data-path="ch3.html"><a href="ch3.html#ch3.1.4"><i class="fa fa-check"></i><b>3.1.4</b> Обработка пропущенных значений</a></li>
<li class="chapter" data-level="3.1.5" data-path="ch3.html"><a href="ch3.html#ch3.1.5"><i class="fa fa-check"></i><b>3.1.5</b> Иллюстрация работы метода CART на конкретных примерах</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Деревянные алгоритмы в R и Python</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="ch2" class="section level1" number="2" style="text-align: justify">
<h1><span class="header-section-number">2</span> Построение деревьев решений CHAID с помощью пакета R CHAID</h1>
<div id="ch2.1" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Знакомство с методом CHAID</h2>
<div id="ch2.1.1" class="section level3" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> Описание алгоритма</h3>
<p>Перед началом работы алгоритма CHAID необходимо преобразовать все имеющиеся количественные предикторы в порядковые переменные. Обычно их разбивают на 10 категорий одинакового объема.</p>
<p>Алгоритм приступает к построению дерева, итеративно применяя к каждому узлу, начиная с корневого, процедуры объединения категорий, расщепления узла и проверки правил остановки.</p>
<p><strong>Этап 1. Объединение категорий</strong></p>
<p>1. Для каждого предиктора с числом категорий больше двух<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> алгоритм ищет пару категорий с наименее значимыми различиями по зависимой переменной, т.е. пару категорий, для которых после применения соответствующего статистического критерия получено наибольшее p-значение. Выбор статистического критерия определяется типом шкалы зависимой переменной. Для номинальной зависимой переменной используется критерий хи-квадрат Пирсона. Алгоритм строит двухвходовую таблицу сопряженности с категориями предиктора в качестве строк и категориями зависимой переменной в качестве столбцов. Он проверяет нулевую гипотезу о том, что категории предиктора не отличаются друг от друга с точки зрения распределения категорий зависимой переменной. Для количественной зависимой переменной используется F-критерий. Алгоритм осуществляет однофакторный дисперсионный анализ и проверяет нулевую гипотезу о том, что средние значения зависимой переменной для различных категорий предиктора не различаются между собой.</p>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>Пакет R <code>CHAID</code> позволяет работать только с категориальной зависимой переменной. Возможность работы с количественной зависимой переменной реализована в процедуре <strong>Деревья классификации/CHAID</strong> проприетарного программного пакета IBM SPSS Statistics и питоновском пакете <code>CHAID</code>.</p>
<p>2. Найдя наибольшее p-значение для пары категорий, алгоритм сравнивает его с заданным уровнем значимости для объединения категорий.</p>
<p>Если p-значение:</p>
<ul>
<li><p>меньше или равно заданному уровню значимости для объединения категорий – алгоритм переходит к вычислению скорректированных p-значений для полученного набора категорий (шаг 3);</p></li>
<li><p>больше уровня значимости для объединения категорий – эта пара объединяется в отдельную составную категорию, в результате формируется новый набор категорий предиктора и процесс начинается заново с поиска пары категорий с наибольшим p-значением.</p></li>
</ul>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID уровень</code> значимости для объединения категорий можно задать c помощью параметра <code>alpha2</code> вспомогательной функции <code>chaid_control()</code>.</p>
<p>(Опциональный шаг) Если новая составная категория состоит из трех и более исходных категорий, алгоритм находит внутри этой составной категории наилучшее бинарное расщепление, которое дает наименьшее p-значение. Алгоритм выполняет бинарное расщепление, если его p-значение не превышает уровня значимости для разбиения объединенных категорий.</p>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID</code> уровень значимости для разбиения уже объединенных категорий можно настроить c помощью параметра <code>alpha3</code> вспомогательной функции <code>chaid_control()</code>.</p>
<p>3. Получив сформированный набор категорий предиктора, алгоритм для категориальной зависимой переменной вновь строит двухвходовую таблицу сопряженности с категориями предиктора в качестве строк и категориями зависимой переменной в качестве столбцов, а для количественной зависимой переменной вновь выполняет однофакторный дисперсионный анализ. В результате алгоритм вычисляет скорректированное p-значение критерия хи-квадрат или F-критерия как исходное p-значение, умноженное на поправку Бонферонни. Поправка Бонферрони представляет собой корректировку уровня значимости в зависимости от числа возможных способов, с помощью которых исходные категории предиктора могут быть объединены в итоговые категории.</p>
<p><strong>Этап 2. Расщепление узла</strong></p>
<p>После вычисления скорректированных p-значений для итоговых наборов категорий по всем предикторам алгоритм переходит к этапу расщепления узла.</p>
<p>1. На этапе расщепления алгоритм выбирает, какой предиктор обеспечит наилучшее разбиение узла. Для этого предиктор должен иметь наименьшее скорректированное p-значение (т.е. должен являться наиболее статистически значимым).</p>
<p>2. Найдя предиктор с наименьшим скорректированным p-значением, алгоритм сравнивает его с заданным уровнем значимости для расщепления.</p>
<p>Если p-значение:</p>
<ul>
<li><p>меньше или равно заданному уровню значимости для расщепления – алгоритм разбивает узел с использованием данного предиктора;</p></li>
<li><p>больше заданного уровня значимости для расщепления, то алгоритм не расщепляет узел и узел рассматривается как терминальный.</p></li>
</ul>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID</code> уровень значимости для расщепления узла можно настроить c помощью параметра <code>alpha4</code> вспомогательной функции <code>chaid_control()</code>.</p>
<p><strong>Этап 3. Остановка</strong></p>
<p>Алгоритм проверяет, нужно ли прекратить построение дерева, в соответствии со следующими правилами остановки:</p>
<ol style="list-style-type: decimal">
<li><p>Если узел стал однородным, то есть все наблюдения в узле имеют одинаковые значения зависимой переменной, узел не разбивается.</p></li>
<li><p>Если текущая глубина дерева достигает заданной пользователем максимальной глубины дерева, процесс построения дерева останавливается.</p></li>
<li><p>Если количество наблюдений в родительском узле меньше заданного пользователем минимума наблюдений в родительском узле, узел не разбивается.</p></li>
<li><p>Если минимальное абсолютное количество наблюдений в терминальном узле меньше заданного пользователем минимума наблюдений в терминальном узле, узел не разбивается.</p></li>
<li><p>Если минимальная относительная частота наблюдений в терминальном узле меньше заданной пользователем минимальной относительной частоты наблюдений в терминальном узле, узел не разбивается.</p></li>
</ol>
<p><em>ПРИМЕЧАНИЕ</em></p>
<p>В пакете R <code>CHAID</code> с помощью ряда параметров вспомогательной функции <code>chaid_control()</code> можно изменить некоторые вышеперечисленные правила остановки:</p>
<ul>
<li><p><code>minsplit</code> задает минимальное количество наблюдений в родительском узле перед расщеплением, по умолчанию 20;</p></li>
<li><p><code>minbucket</code> задает минимальное абсолютное количество наблюдений в терминальном узле, по умолчанию 7;</p></li>
<li><p><code>minprob</code> задает минимальную относительную частоту наблюдений в терминальном узле, по умолчанию 0.01;</p></li>
<li><p><code>maxheight</code> задает максимальную высоту или глубину дерева (количество уровней дерева, лежащих ниже корневого узла), по умолчанию равен -1, т.е. ограничение отсутствует.</p></li>
</ul>
</div>
<div id="ch2.1.2" class="section level3" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> Немного о критерии хи-квадрат</h3>
<p>Предположим, на этапе объединения алгоритм проверяет, различаются ли значимо две категории предиктора <em>Семейное положение</em> <em>“Холост”</em> и <em>“Женат”</em> по зависимой переменной <em>Отклик</em>. Нулевая гипотеза звучит так: категории предиктора не отличаются друг от друга с точки зрения распределения категорий зависимой переменной. Альтернативная гипотеза заключается в том, что категории предиктора все же отличаются друг от друга по зависимой переменной. Строится двухвходовая таблица сопряженности, где строки являются категориями предиктора <em>Семейное положение</em>, а столбцы – категориями зависимой переменной <em>Отклик</em>. Для каждой ячейки таблицы фиксируем наблюдаемую частоту. Затем для каждой ячейки фиксируем ожидаемую частоту согласно нулевой гипотезе. В итоге для каждой ячейки вычисляем квадрат разности между наблюдаемой и ожидаемой частотой, поделенный на ожидаемую частоту. Складываем результаты, вычисленные по каждой ячейке, и получаем значение хи-квадрат (<span class="math inline">\(\chi^{2}\)</span>). Процесс вычисления хи-квадрат проиллюстрирован на рис. 2.1.</p>
<p><img src="figures/2.1.PNG" /></p>
<p><em>Рис. 2.1. Процесс вычисления значения хи-квадрат</em></p>
<p><span class="math display">\[\chi^{2}=\sum\frac{(O-E)^2}{E},\]</span>
где</p>
<p><span class="math inline">\(O\)</span> – наблюдаемые частоты;</p>
<p><span class="math inline">\(E\)</span> – ожидаемые частоты.</p>
<p><span class="math display">\[\chi^{2}=\frac{(20-16,5)^2}{16,5} + \frac{(13-16,5)^2}{16,5} + \frac{(30-33,5)^2}{33,5} + \frac{(37-33,5)^2}{33,5}=2,216\]</span>
Статистика хи-квадрат подчиняется распределению хи-квадрат со степенями свободы <span class="math inline">\(df=(R–1)(C–1)\)</span>, где <span class="math inline">\(R\)</span> и <span class="math inline">\(C\)</span> – количество строк и столбцов в таблице сопряженности. В нашем случае количество степеней свободы будет равно <span class="math inline">\(df=(2–1)(2–1)=1\)</span>.</p>
<p>Чтобы выяснить, достаточно ли велико полученное значение хи-квадрат для отклонения нулевой гипотезы, вычисляем соответствующую ему p-значение. p-значение – это вероятность ошибки, заключающейся в отклонении нулевой гипотезы, когда она верна. Это вероятность того, что случайная величина, имеющая распределение хи-квадрат при условии верности нулевой гипотезы, примет значение, не меньшее, чем вычисленное значение хи-квадрат. Решение об отклонении нулевой гипотезы принимается в результате сравнения p-значения с определенным пороговым уровнем, который называют уровнем значимости (<span class="math inline">\(\alpha\)</span>). Обычно p-значение сравнивают с общепринятым стандартным уровнем значимости<span class="math inline">\(\alpha=0,05\)</span>. Если найденное p-значение меньше уровня значимости, нулевую гипотезу отклоняют, в противном случае у нас нет оснований отвергнуть нулевую гипотезу.</p>
<p>В нашем случае значение хи-квадрат 2,216 с одной степенью свободы соответствует р-значению 0,1366. Таким образом, вероятность того, что статистика хи-квадрат примет вычисленное значение 2,216 и выше, когда категории предиктора <em>Семейное положение</em> не отличаются друг от друга с точки зрения распределения категорий зависимой переменной <em>Отклик</em>, составляет 0,1366. Это превышает уровень значимости 0,05. У нас нет оснований отвергнуть нулевую гипотезу. Можно сделать вывод, что категории переменной <em>Семейное положение</em> действительно не отличаются друг от друга с точки зрения распределения неоткликнувшихся и откликнувшихся клиентов. Данные категории предиктора можно объединить.</p>
<p>Обратите внимание, фраза «нет оснований отклонить нулевую гипотезу» не тождественна фразе «принять нулевую гипотезу», которая является неверной. Нулевая гипотеза обычно имеет очень конкретную формулировку. Например, она может звучит так: нет разницы между средним значением выборки №1 и выборки №2. Если мы не можем отклонить нулевую гипотезу, значит ли это, что данные значения равны? Вовсе не обязательно. То, что нам не удалось найти статистически значимой разницы, совершенно не означает, что мы доказали равенство двух величин. Кроме того, результаты применения статистических критериев зависят от величины различий и от размера выборки, и одинаковые различия на выборках разного размера могут оказаться в одном случае незначимыми (например, если есть две выборки по 20 наблюдений), а в другом (когда наблюдений будет по 1000) – значимыми на том же уровне значимости. Таким образом, мощность статистического критерия (способность выявлять различия там, где они есть) зависит от объема выборки.</p>
<p>Важным практическим моментом в построении деревьев по методу CHAID является то, что по мере роста дерева в узлах остается все меньше и меньше наблюдений, и на определенном этапе мы теряем возможность провести очередное разделение просто в силу малого числа наблюдений в узле. Даже если такое деление могло бы улучшить качество модели на обучающей выборке, оно не будет произведено, если мы не сможем отклонить нулевую гипотезу на заданном уровне значимости; использование поправки Бонферрони только усугубляет эту ситуацию (см. ниже). Но это нельзя однозначно рассматривать как недостаток метода, поскольку описанная особенность является своего рода встроенной регуляризацией, которая может повысить обобщающую способность модели.</p>
</div>
<div id="ch2.1.3" class="section level3" number="2.1.3">
<h3><span class="header-section-number">2.1.3</span> Немного об F-критерии</h3>
<p>Предположим, на этапе объединения категорий алгоритм проверяет, различаются ли значимо категории предиктора <em>Семейное положение</em> <em>“Холост”</em> и <em>“Женат”</em> по количественной зависимой переменной <em>Доход</em>. Нулевая гипотеза будет звучат так: средние значения зависимой переменной в категориях предиктора или группах одинаковы. Чтобы проверить ее, нужно ответить на два вопроса: насколько сильно значения отклоняются от среднего значения зависимой переменной в группах и насколько сильно средние значения зависимой переменной в группах отличаются от среднего значения зависимой переменной перед разбиением на группы. Соответственно выполняется однофакторный дисперсионный анализ, в ходе которого подсчитывают внутригрупповую сумму квадратов отклонений и межгрупповую сумму квадратов отклонений и вычисляют F-критерий (критерий Фишера).</p>
<p>Сумма квадратов между группами (дочерними узлами) определяется по формуле:</p>
<p>Предположим, на этапе объединения категорий алгоритм проверяет, различаются ли значимо категории предиктора Семейное положение Холост и Женат по количественной зависимой переменной Доход. Нулевая гипотеза будет звучат так: средние значения зависимой переменной в категориях предиктора или группах одинаковы. Чтобы проверить ее, нужно ответить на два вопроса: насколько сильно значения отклоняются от среднего значения зависимой переменной в группах и насколько сильно средние значения зависимой переменной в группах отличаются от среднего значения зависимой переменной перед разбиением на группы. Соответственно выполняется однофакторный дисперсионный анализ, в ходе которого подсчитывают внутригрупповую сумму квадратов отклонений и межгрупповую сумму квадратов отклонений и вычисляют F-критерий (критерий Фишера).
Сумма квадратов между группами (дочерними узлами) определяется по формуле:</p>
<p><span class="math display">\[SS_{межгрупп}=\sum^{B}_{i=1}n_i(\bar{y}_{i.}-\bar{y}_{..})^2,\]</span></p>
<p>где</p>
<p><span class="math inline">\(\bar{y}_{i.}\)</span> – среднее значение зависимой переменной в <span class="math inline">\(i\)</span>-том дочернем узле;</p>
<p><span class="math inline">\(\bar{y}_{..}\)</span> – среднее значение зависимой переменной в родительском узле.</p>
<p>Сумма квадратов внутри групп (дочерних узлов) определяется по формуле:</p>
<p><span class="math display">\[SS_{внутригрупп}=\sum^{B}_{i=1}\sum^{n_i}_{j=1}n_i(y_{ij}-\bar{y}_{i.})^2,\]</span></p>
<p>где</p>
<p><span class="math inline">\(y_{ij}\)</span> – значение зависимой переменной для <span class="math inline">\(j\)</span>-ого наблюдения в <span class="math inline">\(i\)</span>-том дочернем узле;</p>
<p><span class="math inline">\(\bar{y}_{i.}\)</span> – среднее значение зависимой переменной в <span class="math inline">\(i\)</span>-том дочернем узле.</p>
<p>Общая сумма квадратов отклонений имеет вид</p>
<p><span class="math display">\[SS_{общая}=\sum^{B}_{i=1}\sum^{n_i}_{j=1}n_i(y_{ij}-\bar{y}_{..})^2\]</span></p>
<p>F-критерий – это отношение межгрупповой суммы квадратов отклонений к внутригрупповой:</p>
<p><span class="math display">\[F=frac_{S_{межгрупп}}{S_{внутригрупп}} \sim F(B-1, n-B)\]</span></p>
<p>Эта статистика подчиняется F-распределению с <span class="math inline">\(B – 1\)</span> и <span class="math inline">\(n – B\)</span> степенями свободы согласно нулевой гипотезе.</p>
<p>p-значение – это вероятность того, что случайная величина с распределением Фишера при условии верности нулевой гипотезы примет значение, не меньшее, чем фактическое значение статистики. Допустим, для нашего примера мы получили значение F-теста 15,943, соответствующее р-значению 0,000. Вероятность того, что F-статистика примет фактическое значение 15,943 и выше, когда средние значения зависимой переменной в категориях предиктора одинаковы, составляет &lt;0,001. Это меньше уровня значимости 0,05. Мы можем отклонить нулевую гипотезу и сделать вывод, что средние значения зависимой переменной в категориях предиктора неодинаковы, а межгрупповые различия являются более существенными, чем внутригрупповые. Данные категории предиктора объединять нельзя.</p>
</div>
<div id="ch2.1.4" class="section level3" number="2.1.4">
<h3><span class="header-section-number">2.1.4</span> Способы объединения категорий предикторов</h3>
<p>Способ объединения категорий предиктора зависит от шкалы его измерения.
В номинальных предикторах можно объединять любые категории, если они не различаются значимо по зависимой переменной. Таким образом, для номинальных переменных ограничения на объединение категорий не накладываются.</p>
<p>В порядковых предикторах две категории могут быть объединены, только если к ним могут быть присоединены промежуточные категории. Например, переменная, представляющая группы по уровню доходов, может рассматриваться как порядковая. Людей с доходом менее 2000$ имеет смысл объединять с теми, кто зарабатывает более 3000$, только если к вновь образовавшейся группе можно также отнести людей с доходом от 2000$ до 3000$.</p>
</div>
<div id="ch2.1.5" class="section level3" number="2.1.5">
<h3><span class="header-section-number">2.1.5</span> Поправка Бонферрони</h3>
<p>Осуществляя поиск незначимых категорий предиктора для объединения, CHAID выполняет большое количество статистических тестов для различных комбинаций категорий предиктора. Однако число таких комбинаций зависит от количества категорий, которое у каждой переменной разное.</p>
<p>Осуществляя поиск незначимых категорий предиктора для объединения, CHAID выполняет большое количество статистических тестов для различных комбинаций категорий предиктора. Однако число таких комбинаций зависит от количества категорий, которое у каждой переменной разное. Например, по одной переменной может оцениваться 2 варианта объединения, рассматриваться 2 таблицы сопряженности и выполняться 2 статистических теста, а по другой переменной – 6 вариантов объединения, 6 таблиц сопряженности и 6 статистических тестов. Вероятность того, что из 6 тестов хи-квадрат для второй переменной по крайней мере один из тестов дает ложное отклонение нулевой гипотезы составляет <span class="math inline">\(1-\prod^{6}_{i=1}(1-\alpha_i)\)</span>.</p>
<p>Групповая вероятность ошибки намного больше индивидуальной вероятности ошибки <span class="math inline">\(\alpha_i\)</span>. Например, если индивидуальная вероятность ошибки (<span class="math inline">\(\alpha_i\)</span>) по каждому тесту равна 0,05, то групповая вероятность ошибки составит <span class="math inline">\(1–0,956 = 0,265\)</span>. Таким образом, при осуществлении множественных проверок гипотез при помощи критерия хи-квадрат (одна проверка на каждое возможное объединение), р-значения недооценивают риск отклонения нулевой гипотезы, когда она верна. Эти рассуждения справедливы и для других статистических критериев. Например, вы можете сделать ошибочный вывод, что заемщики с разными профессиями отличаются по кредитоспособности, тогда как они на самом деле не отличаются.</p>
<p>Если мы хотим, чтобы групповая вероятность ошибки при этом не превышала определенный уровень значимости <span class="math inline">\(\alpha\)</span> (например, 0,05), то, согласно методу Бонферрони, мы должны умножить каждое полученное p-значение на <span class="math inline">\(m\)</span> – количество возможных вариантов объединения с исходных категорий предиктора в <span class="math inline">\(g\)</span> итоговых категорий, получить скорректированное p-значение и сравнить его с уровнем значимости <span class="math inline">\(\alpha\)</span>. Для номинального предиктора множитель <span class="math inline">\(m\)</span> определяется числом Стирлинга второго рода:</p>
<p><span class="math display">\[m=S(c, g) = \sum^{g-1}_{i=1}\frac{(-1)^i(g-i)^c}{i!(g-i)!}\]</span></p>
<p>На рис. 2.2 приводится таблица значений чисел Стирлинга при <span class="math inline">\(0≤c\)</span>, <span class="math inline">\(g≤9\)</span>.</p>
<p><img src="figures/2.2.PNG" /></p>
<p><em>Риc. 2.2. Таблица значений чисел Стерлинга при <span class="math inline">\(0≤c\)</span>, <span class="math inline">\(g≤9\)</span></em></p>
<p>Для порядкового предиктора множитель <span class="math inline">\(m\)</span> определяется как</p>
<p><span class="math display">\[m=\begin{pmatrix}c-1 \\g-1\end{pmatrix}=\frac{(c-1)!}{(g-1)!(c-g)!}\]</span>
Допустим, у нас есть три предиктора. Первый – номинальный предиктор <em>Сlass</em> с 8 категориями. Второй – номинальный предиктор <em>Type</em> с 5 категориями. Третий – порядковый предиктор <em>Incomecat</em> c 4 категориями. По завершении этапа объединения <em>Сlass</em> был преобразован в предиктор с тремя итоговыми категориями, и для него было вычислено p-значение 0,00001; <em>Type</em> был преобразован в предиктор с двумя итоговыми категориями, и для него было вычислено p-значение 0,009; <em>Incomecat</em> был преобразован в предиктор с тремя итоговыми категориями и получил p-значение 0,003. Множитель для предиктора <em>Class</em> равен <span class="math inline">\(m=S(8, 3)=\frac{1}{6}(3^8-3\times2^8+3)=966\)</span>. Таким образом, наше p-значение 0,00001 умножается на 966, и мы получаем скорректированное p-значение 0,00966. Множитель для предиктора <em>Type</em> равен <span class="math inline">\(m=S(5, 2)=2^4-1=15\)</span>. Наше p-значение 0,009 умножается на 15, и мы получаем скорректированное p-значение 0,135. Множитель для предиктора <em>Incomecat</em> равен <span class="math inline">\(m=\frac{(4-1)!}{(3-1)!(4-3)!}=\frac{3!}{2!\times1!}=\frac{6}{2}=3\)</span>. p-значение 0,003 умножается на 3, и мы получаем скорректированное p-значение 0,009. Для разбиения узла выбирается предиктор <em>Incomecat</em>, который имеет наименьшее скорректированное p-значение 0,009.</p>
<p><img src="figures/2.3.PNG" /></p>
<p><em>Риc. 2.3. Количество возможных разбиений переменной из 4 категорий на 2, 3, 4 группы</em></p>
</div>
<div id="ch2.1.6" class="section level3" number="2.1.6">
<h3><span class="header-section-number">2.1.6</span> XCHAID</h3>
<p>В 1991 году Дэвид Биггс, Барри Де Вилль и Эд Суен предложили модификацию метода CHAID – XCHAID (от Exhaustive CHAID – исчерпывающий CHAID). Он был разработан для устранения недостатка CHAID – ограниченного набора расщеплений для предиктора.</p>
<p>Алгоритм XCHAID приступает к построению дерева, итеративно применяя к каждому узлу, начиная с корневого, процедуры объединения категорий, расщепления узла и проверки правил остановки. Этапы расщепления и остановки в XCHAID аналогичны этапам расщепления и остановки в CHAID. Однако на этапе объединения категорий используется процедура более тщательного поиска категорий: пары категорий продолжают сравниваться и объединяться до тех пор, пока не останется одна пара категорий (напомним, что обычный CHAID прекращает объединение категорий, когда обнаруживает, что все оставшиеся категории статистически значимо различаются между собой). Таким образом, XCHAID позволяет найти наилучшее расщепление для каждого предиктора и затем выбрать, какой предиктор нужно расщепить. Вместе с тем, поскольку объединение категорий осуществляется более тщательно, чем в методе CHAID, XCHAID требует большего времени вычислений.</p>
<p><strong>Объединение категорий</strong></p>
<ol style="list-style-type: decimal">
<li><p>Для каждого предиктора с числом категорий больше двух алгоритм ищет пару категорий с наименее значимыми различиями по зависимой переменной. Для категориальной зависимой переменной используется критерий хи-квадрат Пирсона. Для количественной зависимой переменной может использоваться F-критерий.</p></li>
<li><p>Найдя пару с наибольшим p-значением, алгоритм объединяет ее в отдельную составную категорию.</p></li>
<li><p>Для нового набора категорий предиктора алгоритм вычисляет p-значение. Алгоритм запоминает p-значение и соответствующий набор категорий.</p></li>
<li><p>Алгоритм повторяет шаги 1, 2, 3 до тех пор, пока не останутся две категории. Затем среди всех наборов категорий предиктора алгоритм находит набор, у которого p-значение на шаге 3 является наименьшим.</p></li>
<li><p>Алгоритм вычисляет скорректированное p-значение для выбранного набора категорий.</p></li>
</ol>
<p><strong>Расщепление узла</strong></p>
<p>После вычисления скорректированных p-значений для итоговых наборов категорий по всем предикторам алгоритм переходит к этапу расщепления узла.</p>
<ol style="list-style-type: decimal">
<li><p>На этапе расщепления алгоритм выбирает, какой предиктор обеспечит наилучшее разбиение узла, то есть имеет наименьшее скорректированное p-значение (наиболее статистически значимый).</p></li>
<li><p>Найдя предиктор с наименьшим скорректированным p-значением, алгоритм сравнивает его с заданным уровнем значимости для расщепления.</p></li>
</ol>
<p>Если p-значение:</p>
<ul>
<li><p>меньше или равно заданному уровню значимости для расщепления – алгоритм разбивает узел с использованием данного предиктора;</p></li>
<li><p>больше заданного уровня значимости для расщепления, то алгоритм не расщепляет узел и узел рассматривается как терминальный.</p></li>
</ul>
<p><strong>Остановка</strong></p>
<p>Алгоритм проверяет, нужно ли прекратить построение дерева, в соответствии со следующими правилами остановки.</p>
<ol style="list-style-type: decimal">
<li><p>Если узел стал однородным, то есть все наблюдения в узле имеют одинаковые значения зависимой переменной, узел не разбивается.</p></li>
<li><p>Если текущая глубина дерева достигает заданной пользователем максимальной глубины дерева, процесс построения дерева останавливается.</p></li>
<li><p>Если количество наблюдений в родительском узле меньше заданного пользователем минимума наблюдений в родительском узле, узел не разбивается.</p></li>
<li><p>Если минимальное абсолютное количество наблюдений в терминальном узле меньше заданного пользователем минимума наблюдений в терминальном узле, узел не разбивается.</p></li>
<li><p>Если минимальная относительная частота наблюдений в терминальном узле меньше заданной пользователем минимальной относительной частоты наблюдений в терминальном узле, узел не разбивается.</p></li>
</ol>
<p>На практике метод XCHAID строит модель с одинаковой или чуть лучшей дискриминирующей способностью, чем метод CHAID, однако эта разница, как правило, не является статистически значимой. Если учесть, что при одинаковом качестве моделей времени на подгонку в случае использования метода XCHAID требуется больше (особенно это актуально при работе с большими выборками), данный метод используется редко.</p>
</div>
<div id="ch2.1.7" class="section level3" number="2.1.7">
<h3><span class="header-section-number">2.1.7</span> Иллюстрация работы CHAID на конкретном примере</h3>
<p>Предположим, есть данные по клиентам микрофинансовой организации и известно, выплатили они займ или нет (категориальная зависимая переменная <em>Просрочка</em>). В качестве потенциальных предикторов фигурируют четыре переменных: <em>Доход</em>, <em>Возраст</em>, <em>Сфера занятости</em>, <em>Пол</em>. Переменные <em>Пол</em> и <em>Сфера занятости</em> являются номинальными, переменные <em>Доход</em> и <em>Возраст</em> – порядковыми. Переменная <em>Сфера занятости</em> принимает значения <em>“Работает по найму”</em>, <em>“Свое дело”</em>, <em>“Учится или студент”</em>, <em>“Пенсионер”</em>. Переменная <em>Доход</em> принимает значения <em>“Менее 10 тыс. рублей”</em>, <em>“От 10 до 25 тыс. рублей”</em>, <em>“От 26 до 40 тыс. рублей”</em>, <em>“Более 40 тыс. рублей”</em>. Переменная <em>Пол</em> принимает значения <em>“Женщина”</em> и <em>Мужчина</em>. Переменная <em>Возраст</em> принимает значения <em>“&lt;24”</em>, <em>“24-26”</em>, <em>“27-28”</em>, <em>“29-31”</em>, <em>“32-33”</em>, <em>“34-35”</em>, <em>“36-38”</em>, <em>“39-41”</em>, <em>“42-46”</em> и <em>“&gt;46”</em>. Необходимо выяснить, какие группы клиентов с большей вероятностью выйдут в просрочку, чтобы сосредоточить внимание на них. Схематично наши исходные данные представлены на рис. 2.4.</p>
<p><img src="figures/2.4.PNG" /></p>
<p><em>Риc. 2.4. Исходные данные перед началом работы CHAID</em></p>
<p>Что же делает CHAID, когда мы запускаем его? По каждому предиктору CHAID берет пару категорий, сравнивает, различаются ли они по зависимой переменной, и объединяет их, если они не показывают этого различия (дают p-значение больше заданного уровня значимости для объединения).</p>
<p>В нашем случае по порядковому предиктору <em>Доход</em> CHAID сравнивает категорию <em>“Менее 10 тыс. рублей”</em> с категорией <em>“От 10 до 25 тыс. рублей”</em>, затем категорию <em>“От 10 до 25 тыс. рублей”</em> с категорией <em>“От 26 до 40 тыс. рублей”</em>, затем категорию <em>“От 26 до 40 тыс. рублей”</em> с категорией "<em>Более 40 тыс. рублей“<em>. Еще раз обратите внимание, что в порядковом предикторе несмежные категории (например, категория </em>”Менее 10 тыс. рублей"</em> и категория <em>“Более 40 тыс. рублей”</em>) сравниваться и объединяться не могут. Допустим, категории предиктора <em>Доход</em> <em>“Менее 10 тыс. рублей”</em> и <em>“От 10 до 25 тыс. рублей”</em> значимо не различаются по кредитоспособности (в обоих категориях наблюдается высокая доля «плохих» заемщиков), имеют наибольшее p-значение. Тогда CHAID объединяет их и формирует новый набор категорий (объединенная категория <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>, категория <em>“От 26 до 40 тыс. рублей”</em>, категория <em>“Более 40 тыс. рублей”</em>) и снова начинает процесс сравнения. Процесс объединения категорий остановится, когда все оставшиеся категории предиктора будут различаться на заданном уровне значимости для объединения. Сформировав новый набор категорий по предиктору <em>Доход</em>, алгоритм начинает аналогичным образом формировать набор категорий для порядкового предиктора <em>Возраст</em>, опять же сравнивая и объединяя только смежные категории. Затем алгоритм формирует набор категорий для номинального предиктора <em>Сфера занятости</em>. Здесь уже CHAID может сравнивать и объединять любые категории переменной. Затем переходит к предиктору <em>Пол</em>. Здесь категории предиктора Пол не могут быть объединены, поскольку у этой переменной только два уровня. Процесс сравнения и объединения категорий по каждому предиктору показан на рис. 2.5.</p>
<p><img src="figures/2.5.PNG" /></p>
<p><em>Риc. 2.5. Объединение категорий предикторов</em></p>
<p>В итоге получаем преобразованные предикторы <em>Доход</em> (допустим, набор из 3 категорий: объединенная категория <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>, категория <em>“От 26 до 40 тыс. рублей”</em>, категория <em>“Более 40 тыс. рублей”</em>), <em>Сфера занятости</em> (набор из 3 категорий: объединенная категория <em>“Работает по найму/Свое дело”</em>, категория <em>“Учится или студент”</em>, категория <em>“Пенсионер”</em>), <em>Возраст</em> (набор из 3 категорий: объединенная категория <em>“Менее 29 лет”</em>, объединенная категория <em>“От 29 до 46 лет”</em>, категория <em>“Старше 46 лет”</em>) и предиктор <em>Пол</em> (категория <em>“Женщины”</em> и категория <em>“Мужчины”</em>).</p>
<p>Завершив этап объединения, CHAID переходит к этапу разбиения узла (рис. 2.6). Здесь происходит вычисление p-значений для итоговых наборов категорий, затем p-значения корректируются с помощью поправки Бонферрони, чтобы учесть количество сравнений категорий по каждому предиктору.</p>
<p><img src="figures/2.6.PNG" /></p>
<p><em>Риc. 2.6. Выбор предиктора для разбиения узла</em></p>
<p>Например, лучшим предиктором объявлена переменная <em>Доход</em> (имеет наименьшее скорректированное p-значение, не превышающее заданный уровень значимости для разбиения узла). Тогда CHAID обращается к первой новой группе (например, объединенной категории <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>) и снова повторяет вышеописанные шаги, ищет наименее различающиеся категории для объединения и выбирает наиболее значимый предиктор для разбиения. Предположим, что для рассматриваемой группы таким предиктором стал <em>Пол</em>. Тогда CHAID разделяет группу <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em> по переменной <em>Пол</em>. Затем он исследует каждую из оставшихся групп, образованную переменной <em>Доход</em> (категории <em>“От 26 до 40 тыс. рублей”</em>, <em>“Более 40 тыс. рублей”</em>), снова по каждой группе проверяет категории предикторов на объединение и разбивает узел с помощью предиктора, который наиболее значимо связан с зависимой переменной для этой группы. Затем CHAID опускается на следующий уровень дерева и берет первую группу предиктора <em>Пол</em> <em>“Женщины”</em> внутри группы <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>, снова исследует категории и выясняет, есть ли среди предикторов значимо влияющие на зависимую переменную. Если таких предикторов для группы <em>“Женщины”</em> внутри группы <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em> не оказывается или выполняется условие остановки, то CHAID объявляет эту группу терминальным узлом и переходит к аналогичному исследованию группы <em>“Мужчины”</em> внутри группы <em>“Менее 10 тыс. рублей/От 10 до 25 тыс. рублей”</em>.</p>
<p>Таким способом, уровень за уровнем, CHAID систематически разделяет данные на группы (называемые узлами), показывающие значимые различия по отношению к зависимой переменной. Результаты этого процесса представляются в форме дерева, в котором ветвление происходит по мере деления на группы. Взглянув на построенное дерево (рис. 2.7), мы можем с уверенностью ответить на ряд вопросов. Какие из предикторов взаимосвязаны с переменной дефолта, помогают предсказать ее? Какие комбинации категорий этих предикторов дают наибольший процент попадания в интересующую категорию зависимой переменной? Они представляют собой целевые группы, на которых нужно сосредоточить внимание. В следующих разделах будет подробно рассказано, как строить и интерпретировать дерево решений CHAID в пакете R <code>CHAID</code>.</p>
<p><img src="figures/2.7.PNG" /></p>
<p><em>Риc. 2.7. Итоговое дерево CHAID</em></p>
</div>
</div>
<div id="ch2.2" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Предварительная подготовка данных перед построением модели дерева CHAID</h2>
<div id="ch2.2.1" class="section level3" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> Загрузка данных</h3>
<p>Данные, которыми мы воспользуемся для построения дерева классификации CHAID, записаны в файле <em>Churn.csv</em>. Исходная выборка содержит записи о 4431 клиенте, классифицированном на два класса: 0 — оттока нет (2496 клиентов) и 1 — отток есть (1935 клиентов). По каждому наблюдению (клиенту) фиксируются следующие переменные (характеристики):</p>
<ul>
<li><p>порядковый предиктор <em>Длительность междугородних звонков в минутах</em> [<code>longdist</code>];</p></li>
<li><p>порядковый предиктор <em>Длительность местных звонков в минутах</em> [<code>local</code>];</p></li>
<li><p>номинальный предиктор <em>Наличие скидки на междугородние звонки</em> [<code>int_disc</code>];</p></li>
<li><p>номинальный предиктор <em>Тип местных звонков</em> [<code>billtype</code>];</p></li>
<li><p>номинальный предиктор <em>Способ оплаты</em> [<code>pay</code>];</p></li>
<li><p>номинальный предиктор <em>Пол</em> [<code>gender</code>];</p></li>
<li><p>номинальный предиктор <em>Семейное положение</em> [<code>marital</code>];</p></li>
<li><p>количественный предиктор <em>Доход</em> [<code>income</code>];</p></li>
<li><p>порядковый предиктор <em>Возрастная категория</em> [<code>agecat</code>];</p></li>
<li><p>номинальная зависимая переменная <em>Наличие оттока</em> [<code>churn</code>].</p></li>
</ul>
<p>Необходимо разработать модель оттока, с помощью которой предполагается классифицировать новых клиентов на лояльных и склонных к уходу.</p>
<p>Запустим R. Для работы нам потребуются следующие пакеты:</p>
<ul>
<li><p><code>data.table</code>;</p></li>
<li><p><code>Hmisc</code>;</p></li>
<li><p><code>stringr</code>;</p></li>
<li><p><code>car</code>;</p></li>
<li><p><code>imputeMissings</code>;</p></li>
<li><p><code>lsr</code>;</p></li>
<li><p><code>CHAID</code>;</p></li>
<li><p><code>pROC</code>;</p></li>
<li><p><code>precrec</code>;</p></li>
<li><p><code>readxl</code>.</p></li>
</ul>
<p>Давайте установим их с помощью функции <code>install.packages()</code>. Если вы используете консольную версию R, вам будет предложено выбрать постоянный CRAN-репозиторий, из которого будут устанавливаться пакеты.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="ch2.html#cb1-1"></a><span class="kw">install.packages</span>(<span class="st">&quot;data.table&quot;</span>)</span>
<span id="cb1-2"><a href="ch2.html#cb1-2"></a><span class="kw">install.packages</span>(<span class="st">&quot;Hmisc&quot;</span>)</span>
<span id="cb1-3"><a href="ch2.html#cb1-3"></a><span class="kw">install.packages</span>(<span class="st">&quot;stringr&quot;</span>)</span>
<span id="cb1-4"><a href="ch2.html#cb1-4"></a><span class="kw">install.packages</span>(<span class="st">&quot;car&quot;</span>)</span>
<span id="cb1-5"><a href="ch2.html#cb1-5"></a><span class="kw">install.packages</span>(<span class="st">&quot;imputeMissings&quot;</span>)</span>
<span id="cb1-6"><a href="ch2.html#cb1-6"></a><span class="kw">install.packages</span>(<span class="st">&quot;lsr&quot;</span>)</span>
<span id="cb1-7"><a href="ch2.html#cb1-7"></a><span class="kw">install.packages</span>(<span class="st">&quot;CHAID&quot;</span>, <span class="dt">repos =</span> <span class="st">&quot;http://R-Forge.R-project.org&quot;</span>)</span>
<span id="cb1-8"><a href="ch2.html#cb1-8"></a><span class="kw">install.packages</span>(<span class="st">&quot;pROC&quot;</span>)</span>
<span id="cb1-9"><a href="ch2.html#cb1-9"></a><span class="kw">install.packages</span>(<span class="st">&quot;precrec&quot;</span>)</span>
<span id="cb1-10"><a href="ch2.html#cb1-10"></a><span class="kw">install.packages</span>(<span class="st">&quot;readxl&quot;</span>)</span></code></pre></div>
<p>Иногда при установке пакетов появляется ошибка: *dependencies название_пакета are not available for package название_ <em>устанавливаемого</em> _пакета*. Это говорит о том, что перед установкой основного пакета вы должны установить требуемые пакеты-зависимости.</p>
<p>После установки пакетов их можно загрузить для работы с помощью функции <code>library()</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="ch2.html#cb2-1"></a><span class="kw">library</span>(data.table)</span>
<span id="cb2-2"><a href="ch2.html#cb2-2"></a><span class="kw">library</span>(Hmisc)</span>
<span id="cb2-3"><a href="ch2.html#cb2-3"></a><span class="kw">library</span>(stringr)</span>
<span id="cb2-4"><a href="ch2.html#cb2-4"></a><span class="kw">library</span>(car)</span>
<span id="cb2-5"><a href="ch2.html#cb2-5"></a><span class="kw">library</span>(imputeMissings)</span>
<span id="cb2-6"><a href="ch2.html#cb2-6"></a><span class="kw">library</span>(lsr)</span>
<span id="cb2-7"><a href="ch2.html#cb2-7"></a><span class="kw">library</span>(CHAID)</span>
<span id="cb2-8"><a href="ch2.html#cb2-8"></a><span class="kw">library</span>(pROC)</span>
<span id="cb2-9"><a href="ch2.html#cb2-9"></a><span class="kw">library</span>(precrec)</span>
<span id="cb2-10"><a href="ch2.html#cb2-10"></a><span class="kw">library</span>(readxl)</span></code></pre></div>
<p>При помощи функции <code>data.table::fread()</code> загрузим файл <em>Churn.csv</em> в таблицу данных <code>dt</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="ch2.html#cb3-1"></a>dt &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;data/Churn.csv&quot;</span>, <span class="dt">dec =</span> <span class="st">&quot;,&quot;</span>) <span class="co"># указываем десятичный разделитель</span></span></code></pre></div>
</div>
<div id="ch2.2.2" class="section level3" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> Фиксация пустых строковых значений как пропусков</h3>
<p>Данные часто содержат пропуски. По умолчанию пропуски для вещественных и целочисленных векторов будут записаны как значения <code>NA</code> (not available – нет в наличии), а пропуски для строк и факторов специально никак не помечаются и представлены как пустые строковые значения (обозначение <code>NA</code> не используется, потому что у фактора может быть действительный уровень <code>"NA"</code>). Кроме того, есть еще недопустимые значения – значения <code>NaN</code> (not a number – не являются числом), а также бесконечные значения – значения <code>Inf</code> и <code>–Inf</code>. Давайте взглянем на первые 10 наблюдений:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="ch2.html#cb4-1"></a><span class="kw">head</span>(dt, <span class="dt">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##     longdist local int_disc   billtype  pay  gender  marital  income agecat churn
##  1:       &lt;2    &lt;8      Нет  Бюджетный   CC Мужской    Женат 77680.0    &lt;31     1
##  2:             &lt;8      Нет Бесплатный   CC Мужской    Женат 37111.5    &lt;31     1
##  3:       &lt;2    &lt;8      Нет              CC Мужской    Женат      NA            1
##  4:       &lt;2    &lt;8          Бесплатный   CH Мужской Одинокий      NA    &lt;31     0
##  5:       &lt;2            Нет Бесплатный Auto         Одинокий 16829.6    &lt;31     1
##  6:             &lt;8      Нет Бесплатный      Женский Одинокий 57272.7    &lt;31     1
##  7:             &lt;8      Нет  Бюджетный      Мужской    Женат      NA    &lt;31     1
##  8:       &lt;2    &lt;8      Нет Бесплатный Auto Мужской               NA    &lt;31     1
##  9:       &lt;2    &lt;8       Да              CH Мужской Одинокий 92167.3    &lt;31     1
## 10:       &lt;2    &lt;8      Нет Бесплатный   CC Мужской    Женат 37135.5    &lt;31     1</code></pre>
<p>Переменные <code>longdist</code>, <code>local</code>, <code>int_disc</code>, <code>billtype</code>, <code>pay</code>, <code>gender</code>, <code>marital</code>, <code>agecat</code> и <code>churn</code> представлены строковыми значениями. При этом переменные <code>longdist</code>, <code>local</code>, <code>int_disc</code>, <code>billtype</code>, <code>pay</code>, <code>gender</code>, <code>marital</code> и agecat в некоторых наблюдениях имеют пустые строковые значения. Переменная <code>income</code>, которая представлена числовыми значениями, в ряде наблюдений имеет значения <code>NA</code>. Пустые строковые значения и значения <code>NA</code> и есть наши фактические пропуски. Обратите внимание, что для корректной обработки пропущенных значений необходимо пометить пустые строковые значения как пропуски. Например, выведем количество пропусков по переменной <code>income</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="ch2.html#cb6-1"></a>dt[, <span class="kw">sum</span>(<span class="kw">is.na</span>(income))]</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p>Для вычислений сначала используем функцию <code>is.na()</code>, которая определяет, является ли значение пропущенным или нет (возвращает логическое значение <code>TRUE</code> или <code>FALSE</code> соответственно). Затем функция <code>sum()</code> подсчитывает количество пропусков как сумму логических значений <code>TRUE</code>.</p>
<p>Теперь выведем количество пропусков по переменной <code>pay</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="ch2.html#cb8-1"></a>dt[, <span class="kw">sum</span>(<span class="kw">is.na</span>(pay))]</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>Однако мы точно знаем, пропуски есть. Заменим все пустые строковые значения на <code>NA</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="ch2.html#cb10-1"></a><span class="kw">is.na</span>(dt) &lt;-<span class="st"> </span>dt <span class="op">==</span><span class="st"> &quot;&quot;</span></span></code></pre></div>
<p>Снова выведем первые 10 наблюдений нашей таблицы:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="ch2.html#cb11-1"></a><span class="kw">head</span>(dt, <span class="dt">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##     longdist local int_disc   billtype  pay  gender  marital  income agecat churn
##  1:       &lt;2    &lt;8      Нет  Бюджетный   CC Мужской    Женат 77680.0    &lt;31     1
##  2:     &lt;NA&gt;    &lt;8      Нет Бесплатный   CC Мужской    Женат 37111.5    &lt;31     1
##  3:       &lt;2    &lt;8      Нет       &lt;NA&gt;   CC Мужской    Женат      NA   &lt;NA&gt;     1
##  4:       &lt;2    &lt;8     &lt;NA&gt; Бесплатный   CH Мужской Одинокий      NA    &lt;31     0
##  5:       &lt;2  &lt;NA&gt;      Нет Бесплатный Auto    &lt;NA&gt; Одинокий 16829.6    &lt;31     1
##  6:     &lt;NA&gt;    &lt;8      Нет Бесплатный &lt;NA&gt; Женский Одинокий 57272.7    &lt;31     1
##  7:     &lt;NA&gt;    &lt;8      Нет  Бюджетный &lt;NA&gt; Мужской    Женат      NA    &lt;31     1
##  8:       &lt;2    &lt;8      Нет Бесплатный Auto Мужской     &lt;NA&gt;      NA    &lt;31     1
##  9:       &lt;2    &lt;8       Да       &lt;NA&gt;   CH Мужской Одинокий 92167.3    &lt;31     1
## 10:       &lt;2    &lt;8      Нет Бесплатный   CC Мужской    Женат 37135.5    &lt;31     1</code></pre>
<p>Пустые строковые значения теперь помечены как <code>&lt;NA&gt;</code>: символы <code>&lt;&gt;</code> используются для того, чтобы пропуски можно было отличить от возможного действительного значения <code>"NA"</code>.</p>
<p>Сумма пропусков по переменной <code>pay</code> после того, как пустые строковые значения были помечены как пропуски:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="ch2.html#cb13-1"></a>dt[, <span class="kw">sum</span>(<span class="kw">is.na</span>(pay))]</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>Еще более удобный вариант зафиксировать пустые строковые значения как пропуски – использование при загрузке данных значения параметра <code>na.strings = ""</code> (в нашем примере; при необходимости можно задать вектор из строковых значений, рассматриваемых как пропуски):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="ch2.html#cb15-1"></a>dt &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;data/Churn.csv&quot;</span>, <span class="dt">dec =</span> <span class="st">&quot;,&quot;</span>,  <span class="dt">na.strings =</span> <span class="st">&quot;&quot;</span>)</span></code></pre></div>
</div>
<div id="ch2.2.3" class="section level3" number="2.2.3">
<h3><span class="header-section-number">2.2.3</span> Вывод подробной информации о переменных</h3>
<p>Для проведения предварительной обработки данных необходимо получить более развернутую информацию о переменных. В таких случаях можно воспользоваться функцией <code>describe()</code> из пакета <code>Hmisc</code>, разработанным Фрэнком Харреллом, профессором биостастистики Вандербильтского университета, экспертом Центра оценки и исследований биопрепаратов Управления по санитарному надзору за качеством пищевых продуктов и медикаментов (CDER FDA).</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="ch2.html#cb16-1"></a><span class="kw">describe</span>(dt)</span></code></pre></div>
<pre><code>## dt 
## 
##  10  Variables      4431  Observations
## ---------------------------------------------------------------------------------------------
## longdist 
##        n  missing distinct 
##     4428        3        5 
## 
## lowest : &lt;2    15-20 2-8   21+   9-14 , highest: &lt;2    15-20 2-8   21+   9-14 
##                                         
## Value         &lt;2 15-20   2-8   21+  9-14
## Frequency    738  1055   868   773   994
## Proportion 0.167 0.238 0.196 0.175 0.224
## ---------------------------------------------------------------------------------------------
## local 
##        n  missing distinct 
##     4430        1        5 
## 
## lowest : &lt;8    21-35 36-55 56+   8-20 , highest: &lt;8    21-35 36-55 56+   8-20 
##                                         
## Value         &lt;8 21-35 36-55   56+  8-20
## Frequency    740  1447   738   741   764
## Proportion 0.167 0.327 0.167 0.167 0.172
## ---------------------------------------------------------------------------------------------
## int_disc 
##        n  missing distinct 
##     4430        1        2 
##                       
## Value         Да   Нет
## Frequency   1377  3053
## Proportion 0.311 0.689
## ---------------------------------------------------------------------------------------------
## billtype 
##        n  missing distinct 
##     4429        2        2 
##                                 
## Value      Бесплатный  Бюджетный
## Frequency        2185       2244
## Proportion      0.493      0.507
## ---------------------------------------------------------------------------------------------
## pay 
##        n  missing distinct 
##     4429        2        4 
##                                   
## Value       Auto    CC    CD    CH
## Frequency    890  2560     2   977
## Proportion 0.201 0.578 0.000 0.221
## ---------------------------------------------------------------------------------------------
## gender 
##        n  missing distinct 
##     4430        1        4 
##                                                   
## Value        Женский Женский&amp;*   Мужской Мужской&amp;*
## Frequency       2236         8      2182         4
## Proportion     0.505     0.002     0.493     0.001
## ---------------------------------------------------------------------------------------------
## marital 
##        n  missing distinct 
##     4430        1        5 
## 
## lowest : _Женат    _Одинокий Же&amp;нат    Женат     Одинокий 
## highest: _Женат    _Одинокий Же&amp;нат    Женат     Одинокий 
##                                                             
## Value         _Женат _Одинокий    Же&amp;нат     Женат  Одинокий
## Frequency          6         6         2      2620      1796
## Proportion     0.001     0.001     0.000     0.591     0.405
## ---------------------------------------------------------------------------------------------
## income 
##        n  missing distinct     Info     Mean      Gmd      .05      .10      .25      .50 
##     4427        4     1456        1    50318    32838     5613    11255    25446    50291 
##      .75      .90      .95 
##    75135    90189    94865 
## 
## lowest :   110.28   127.24   295.94   349.09   540.41, highest: 99488.10 99514.60 99563.10 99619.90 99832.90
## ---------------------------------------------------------------------------------------------
## agecat 
##        n  missing distinct 
##     4430        1        5 
## 
## lowest : &lt;31   31-45 46-58 59-70 71+  , highest: &lt;31   31-45 46-58 59-70 71+  
##                                         
## Value        &lt;31 31-45 46-58 59-70   71+
## Frequency    755  1306   911   717   741
## Proportion 0.170 0.295 0.206 0.162 0.167
## ---------------------------------------------------------------------------------------------
## churn 
##        n  missing distinct     Info      Sum     Mean      Gmd 
##     4431        0        2    0.738     1935   0.4367   0.4921 
## 
## ---------------------------------------------------------------------------------------------</code></pre>
<p>В полученном отчете первой приводится информация о количестве переменных и общем количестве наблюдений. Для каждой категориальной (строковой) переменной приводятся <code>n</code> – количество непропущенных наблюдений, <code>missing</code> – количество пропущенных значений, <code>distinct</code> – количество уникальных значений. Для каждой количественной переменной приводятся <code>n</code> – количество непропущенных наблюдений, <code>missing</code> – количество пропущенных значений, <code>distinct</code> – количество уникальных значений, <code>Info</code> – мера информативности, <code>Mean</code> – среднее значение, <code>Gmd</code> – средняя разность Джини, <code>.05</code> – 5%-ный квантиль, <code>.10</code> – 10%-ный квантиль, <code>.25</code> – 25%-ный квантиль, <code>.50</code> – 50%-ный квантиль (медиана), <code>.75</code> – 75%-ный квантиль, <code>.90</code> – 90%-ный квантиль, <code>.95</code> – 95%-ный квантиль.</p>
<p>Показатель <code>Info</code> вычисляется как единица минус сумма кубов относительных частот уникальных значений, деленная на единицу минус квадрат обратной величины размера выборки:</p>
<p><span class="math display">\[Info = \frac{1-\sum^{k}_{i=1}f^3_i}{1-(n^{-1})^2},\]</span>
где</p>
<p><span class="math inline">\(f_i\)</span> – частота <span class="math inline">\(i\)</span>-той категории переменной;</p>
<p><span class="math inline">\(n^{-1}\)</span> – обратная величина размера выборки (единица, деленная на общее количество наблюдений).</p>
<p>Наименьшие значения информативности получают переменные, имеющее одно уникальное значение, а также бинарные переменные с сильно отличающимися относительными частотами.</p>
</div>
<div id="ch2.2.4" class="section level3" number="2.2.4">
<h3><span class="header-section-number">2.2.4</span> Нормализация строковых значений</h3>
<p>Обратимся к переменным <code>gender</code> и <code>marital</code> в отчете, сгенерированном функцией <code>Hmisc::describe()</code>. Видно, что значения этих переменных содержат лишние символы:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="ch2.html#cb18-1"></a><span class="kw">describe</span>(dt[, .(gender, marital)])</span></code></pre></div>
<pre><code>## dt[, .(gender, marital)] 
## 
##  2  Variables      4431  Observations
## ---------------------------------------------------------------------------------------------
## gender 
##        n  missing distinct 
##     4430        1        4 
##                                                   
## Value        Женский Женский&amp;*   Мужской Мужской&amp;*
## Frequency       2236         8      2182         4
## Proportion     0.505     0.002     0.493     0.001
## ---------------------------------------------------------------------------------------------
## marital 
##        n  missing distinct 
##     4430        1        5 
## 
## lowest : _Женат    _Одинокий Же&amp;нат    Женат     Одинокий 
## highest: _Женат    _Одинокий Же&amp;нат    Женат     Одинокий 
##                                                             
## Value         _Женат _Одинокий    Же&amp;нат     Женат  Одинокий
## Frequency          6         6         2      2620      1796
## Proportion     0.001     0.001     0.000     0.591     0.405
## ---------------------------------------------------------------------------------------------</code></pre>
<p>Кроме того, распределения значений переменных можно вывести, воспользовавшись функциями <code>lapply()</code> и <code>summary()</code>. Функция <code>lapply()</code> применяет заданную нами функцию (в данном случае <code>summary()</code>) к элементам вектора или списка, возвращая результат в виде списка (буква <code>l</code> в названии <code>lapply</code> означает list – «список»).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="ch2.html#cb20-1"></a><span class="co"># Для корректной работы функции summary переменную нужно превратить в фактор</span></span>
<span id="cb20-2"><a href="ch2.html#cb20-2"></a><span class="kw">lapply</span>(dt[, .(gender, marital)], <span class="cf">function</span>(x) <span class="kw">summary</span>(<span class="kw">as.factor</span>(x)))</span></code></pre></div>
<pre><code>## $gender
##   Женский Женский&amp;*   Мужской Мужской&amp;*      NA&#39;s 
##      2236         8      2182         4         1 
## 
## $marital
##    _Женат _Одинокий    Же&amp;нат     Женат  Одинокий      NA&#39;s 
##         6         6         2      2620      1796         1</code></pre>
<p>Если нужно вывести только уровни переменных, можно воспользоваться функциями <code>lapply()</code> и <code>levels()</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="ch2.html#cb22-1"></a><span class="kw">lapply</span>(dt[, .(gender, marital)], <span class="cf">function</span>(x) <span class="kw">levels</span>(<span class="kw">as.factor</span>(x)))</span></code></pre></div>
<pre><code>## $gender
## [1] &quot;Женский&quot;   &quot;Женский&amp;*&quot; &quot;Мужской&quot;   &quot;Мужской&amp;*&quot;
## 
## $marital
## [1] &quot;_Женат&quot;    &quot;_Одинокий&quot; &quot;Же&amp;нат&quot;    &quot;Женат&quot;     &quot;Одинокий&quot;</code></pre>
<p>Давайте удалим ненужные символы <code>&amp;*</code>, которыми заканчиваются несколько значений переменной <code>gender</code>, с помощью функции <code>gsub()</code>. Она имеет общий вид <code>gsub(pattern, replacement, x)</code>, где:</p>
<ul>
<li><p><code>pattern</code> – подстрока, которую следует найти;</p></li>
<li><p><code>replacement</code> – подстрока, на которую следует выполнить замену;</p></li>
<li><p><code>x</code> – строка или вектор строк, по которым выполняется поиск.</p></li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="ch2.html#cb24-1"></a>dt[, gender <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">&amp;</span><span class="ch">\\</span><span class="st">*&quot;</span>, <span class="st">&quot;&quot;</span>, gender)]</span></code></pre></div>
<p>Обратите внимание на использование оператора <code>:=</code> из пакета <code>data.table</code>, позволяющего изменять объект без создания копий и повторного присваивания. При работе с большими таблицами это увеличивает скорость выполнения операций и уменьшает расход ОЗУ.</p>
<p>Для удаления лишних символов в значениях переменной <code>marital</code> воспользуемся альтернативным способом – функцией <code>str_replace_all()</code> пакета <code>stringr</code>. Она имеет общий вид <code>str_replace_all(string, pattern, replacement)</code>, где:</p>
<ul>
<li><p><code>x</code> – строка или вектор строк, по которым выполняется поиск;</p></li>
<li><p><code>pattern</code> – подстрока, которую следует найти;</p></li>
<li><p><code>replacement</code> – подстрока, на которую следует выполнить замену.</p></li>
</ul>
<p>В данном случае для удаления лишних символов мы воспользуемся символьными классами POSIX. На рис. 2.8 приводятся наиболее часто используемые символьные классы POSIX.</p>
<p><img src="figures/2.8.PNG" /></p>
<p><em>Риc. 2.8. Наиболее распространенные классы POSIX</em></p>
<p>Нам понадобится символьный класс <code>[:alnum:]</code>, который находит символы, являющиеся буквами и цифрами. Обратите внимание, что использование класса возможно лишь внутри квадратных скобок. Конструкция <code>[^[:alnum:]]</code> обозначает «найти все символы, не являющиеся буквами и цифрами».</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="ch2.html#cb25-1"></a>dt[, marital <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">str_replace_all</span>(marital, <span class="st">&quot;[^[:alnum:]]&quot;</span>, <span class="st">&quot;&quot;</span>)]</span></code></pre></div>
<p>Снова выводим уровни переменных:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="ch2.html#cb26-1"></a><span class="kw">lapply</span>(dt[, .(gender, marital)], <span class="cf">function</span>(x) <span class="kw">levels</span>(<span class="kw">as.factor</span>(x)))</span></code></pre></div>
<pre><code>## $gender
## [1] &quot;Женский&quot; &quot;Мужской&quot;
## 
## $marital
## [1] &quot;Женат&quot;    &quot;Одинокий&quot;</code></pre>
<p>Видим, что лишние символы удалены и можно продолжать работу.</p>
</div>
<div id="ch2.2.5" class="section level3" number="2.2.5">
<h3><span class="header-section-number">2.2.5</span> Обработка дублирующихся наблюдений</h3>
<p>Очень часто при подготовке выборки допускаются ошибки, в частности, в набор данных несколько раз может попасть одно и то же наблюдение. Давайте убедимся, что наш набор не содержит дублирующихся наблюдений (строк). Для этого мы воспользуемся функцией <code>duplicated()</code>, которая выведет все повторяющиеся наблюдения:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="ch2.html#cb28-1"></a>dt[<span class="kw">duplicated</span>(dt), ]</span></code></pre></div>
<pre><code>##    longdist local int_disc   billtype  pay  gender  marital  income agecat churn
## 1:       &lt;2    &lt;8      Нет  Бюджетный   CC Женский    Женат 32118.4    71+     1
## 2:       &lt;2    &lt;8       Да Бесплатный   CC Женский Одинокий 18831.1  46-58     1
## 3:      21+ 21-35      Нет  Бюджетный   CC Мужской    Женат 84269.0  31-45     0
## 4:     9-14   56+      Нет  Бюджетный   CC Мужской Одинокий 54643.3  31-45     0
## 5:      2-8 21-35      Нет Бесплатный Auto Женский    Женат 92353.3  46-58     0
## 6:    15-20 21-35      Нет Бесплатный   CC Женский    Женат 87404.6  46-58     1
## 7:      21+  8-20      Нет Бесплатный   CC Женский Одинокий 75639.8  31-45     0</code></pre>
<p>Теперь с помощью функции unique оставим в нашем наборе только уникальные, недублирующиеся наблюдения:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="ch2.html#cb30-1"></a>dt &lt;-<span class="st"> </span><span class="kw">unique</span>(dt)</span>
<span id="cb30-2"><a href="ch2.html#cb30-2"></a></span>
<span id="cb30-3"><a href="ch2.html#cb30-3"></a>dt[, .N] <span class="co"># количество строк в итоговой таблице</span></span></code></pre></div>
<pre><code>## [1] 4424</code></pre>
</div>
<div id="ch2.2.6" class="section level3" number="2.2.6">
<h3><span class="header-section-number">2.2.6</span> Изменение типов переменных</h3>
<p>Теперь посмотрим, как выглядят наши переменные:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="ch2.html#cb32-1"></a><span class="kw">str</span>(dt)</span></code></pre></div>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:	4424 obs. of  10 variables:
##  $ longdist: chr  &quot;&lt;2&quot; NA &quot;&lt;2&quot; &quot;&lt;2&quot; ...
##  $ local   : chr  &quot;&lt;8&quot; &quot;&lt;8&quot; &quot;&lt;8&quot; &quot;&lt;8&quot; ...
##  $ int_disc: chr  &quot;Нет&quot; &quot;Нет&quot; &quot;Нет&quot; NA ...
##  $ billtype: chr  &quot;Бюджетный&quot; &quot;Бесплатный&quot; NA &quot;Бесплатный&quot; ...
##  $ pay     : chr  &quot;CC&quot; &quot;CC&quot; &quot;CC&quot; &quot;CH&quot; ...
##  $ gender  : chr  &quot;Мужской&quot; &quot;Мужской&quot; &quot;Мужской&quot; &quot;Мужской&quot; ...
##  $ marital : chr  &quot;Женат&quot; &quot;Женат&quot; &quot;Женат&quot; &quot;Одинокий&quot; ...
##  $ income  : num  77680 37112 NA NA 16830 ...
##  $ agecat  : chr  &quot;&lt;31&quot; &quot;&lt;31&quot; NA &quot;&lt;31&quot; ...
##  $ churn   : int  1 1 1 0 1 1 1 1 1 1 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>В сводке мы видим, что количественная переменная <code>income</code> правильно записана как вещественный вектор, потому что ее значения являются числами с плавающей точкой. Номинальные переменные <code>int_disc</code>, <code>billtype</code>, <code>pay</code>, <code>gender</code>, <code>marital</code> следует превратить в факторы, для представления их строковых значений будут использоваться неупорядоченные числовые коды:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="ch2.html#cb34-1"></a>fact_cols &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;int_disc&quot;</span>, <span class="st">&quot;billtype&quot;</span>, <span class="st">&quot;pay&quot;</span>, <span class="st">&quot;gender&quot;</span>, <span class="st">&quot;marital&quot;</span>)</span>
<span id="cb34-2"><a href="ch2.html#cb34-2"></a>dt[, (fact_cols) <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">lapply</span>(.SD, as.factor), .SDcols =<span class="st"> </span>fact_cols]</span></code></pre></div>
<p>Переменные <code>longdist</code>, <code>local</code> и <code>agecat</code> представляют собой упорядоченные факторы, поэтому для них дополнительно нужно указать <code>ordered = TRUE</code> и задать вектор символьных меток (категорий), выстроенных по порядку, при помощи параметра <code>labels</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="ch2.html#cb35-1"></a>dt[, </span>
<span id="cb35-2"><a href="ch2.html#cb35-2"></a>   longdist <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">factor</span>(longdist, </span>
<span id="cb35-3"><a href="ch2.html#cb35-3"></a>                      <span class="dt">ordered =</span> <span class="ot">TRUE</span>, </span>
<span id="cb35-4"><a href="ch2.html#cb35-4"></a>                      <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;&lt;2&quot;</span>, <span class="st">&quot;2-8&quot;</span>, <span class="st">&quot;9-14&quot;</span>, <span class="st">&quot;15-20&quot;</span>, <span class="st">&quot;21+&quot;</span>))</span>
<span id="cb35-5"><a href="ch2.html#cb35-5"></a>   ]</span>
<span id="cb35-6"><a href="ch2.html#cb35-6"></a></span>
<span id="cb35-7"><a href="ch2.html#cb35-7"></a>dt[, </span>
<span id="cb35-8"><a href="ch2.html#cb35-8"></a>   local <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">factor</span>(local, </span>
<span id="cb35-9"><a href="ch2.html#cb35-9"></a>                   <span class="dt">ordered =</span> <span class="ot">TRUE</span>, </span>
<span id="cb35-10"><a href="ch2.html#cb35-10"></a>                   <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;&lt;8&quot;</span>, <span class="st">&quot;8-20&quot;</span>, <span class="st">&quot;21-35&quot;</span>, <span class="st">&quot;36-55&quot;</span>, <span class="st">&quot;56+&quot;</span>))</span>
<span id="cb35-11"><a href="ch2.html#cb35-11"></a>   ]</span>
<span id="cb35-12"><a href="ch2.html#cb35-12"></a></span>
<span id="cb35-13"><a href="ch2.html#cb35-13"></a>dt[, </span>
<span id="cb35-14"><a href="ch2.html#cb35-14"></a>   agecat <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">factor</span>(agecat, </span>
<span id="cb35-15"><a href="ch2.html#cb35-15"></a>                    <span class="dt">ordered =</span> <span class="ot">TRUE</span>, </span>
<span id="cb35-16"><a href="ch2.html#cb35-16"></a>                    <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;&lt;31&quot;</span>, <span class="st">&quot;31-45&quot;</span>, <span class="st">&quot;46-58&quot;</span>, <span class="st">&quot;59-70&quot;</span>, <span class="st">&quot;71+&quot;</span>))</span>
<span id="cb35-17"><a href="ch2.html#cb35-17"></a>   ]</span></code></pre></div>
<p>Номинальная зависимая переменная <code>churn</code> неправильно (в контексте нашей задачи) записана как целочисленный вектор, поскольку она представлена целочисленными значениями. Если мы будем строить модель с такой зависимой переменной, будет возвращена ошибка, так как <code>CHAID</code> работает только с номинальной зависимой переменной, представленной в виде фактора, а в других пакетах R (например, <code>rpart</code> и <code>randomForest</code>) вместо задачи классификации будет решаться задача регрессии. Присвоим переменной <code>churn</code> правильный тип <code>factor</code> с уровнями <code>"Остается"</code> (<code>0</code>) и <code>"Уходит"</code> (<code>1</code>):</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="ch2.html#cb36-1"></a>dt[, </span>
<span id="cb36-2"><a href="ch2.html#cb36-2"></a>  churn <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">factor</span>(churn, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;Остается&quot;</span>, <span class="st">&quot;Уходит&quot;</span>))</span>
<span id="cb36-3"><a href="ch2.html#cb36-3"></a>  ]</span></code></pre></div>
<p>После выполнения необходимых преобразований набор данных выглядит следующим образом:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="ch2.html#cb37-1"></a><span class="kw">str</span>(dt)</span></code></pre></div>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:	4424 obs. of  10 variables:
##  $ longdist: Ord.factor w/ 5 levels &quot;&lt;2&quot;&lt;&quot;2-8&quot;&lt;&quot;9-14&quot;&lt;..: 1 NA 1 1 1 NA NA 1 1 1 ...
##  $ local   : Ord.factor w/ 5 levels &quot;&lt;8&quot;&lt;&quot;8-20&quot;&lt;&quot;21-35&quot;&lt;..: 1 1 1 1 NA 1 1 1 1 1 ...
##  $ int_disc: Factor w/ 2 levels &quot;Да&quot;,&quot;Нет&quot;: 2 2 2 NA 2 2 2 2 1 2 ...
##  $ billtype: Factor w/ 2 levels &quot;Бесплатный&quot;,&quot;Бюджетный&quot;: 2 1 NA 1 1 1 2 1 NA 1 ...
##  $ pay     : Factor w/ 4 levels &quot;Auto&quot;,&quot;CC&quot;,&quot;CD&quot;,..: 2 2 2 4 1 NA NA 1 4 2 ...
##  $ gender  : Factor w/ 2 levels &quot;Женский&quot;,&quot;Мужской&quot;: 2 2 2 2 NA 1 2 2 2 2 ...
##  $ marital : Factor w/ 2 levels &quot;Женат&quot;,&quot;Одинокий&quot;: 1 1 1 2 2 2 1 NA 2 1 ...
##  $ income  : num  77680 37112 NA NA 16830 ...
##  $ agecat  : Ord.factor w/ 5 levels &quot;&lt;31&quot;&lt;&quot;31-45&quot;&lt;..: 1 1 NA 1 1 1 1 1 1 1 ...
##  $ churn   : Factor w/ 2 levels &quot;Остается&quot;,&quot;Уходит&quot;: 2 2 2 1 2 2 2 2 2 2 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
</div>
<div id="ch2.2.7" class="section level3" number="2.2.7">
<h3><span class="header-section-number">2.2.7</span> Обработка редких категорий</h3>
<p>Теперь обратимся к переменной <code>pay</code> в отчете, сгенерированном функцией <code>Hmisc::describe()</code> . Мы видим, что категория <code>CD</code> встречается лишь 2 раза. Распределение значений этой переменной можно также вывести с помощью функции <code>summary()</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="ch2.html#cb39-1"></a><span class="kw">summary</span>(dt<span class="op">$</span>pay)</span></code></pre></div>
<pre><code>## Auto   CC   CD   CH NA&#39;s 
##  889 2554    2  977    2</code></pre>
<p>Такие редкие категории, как категория <code>CD</code>, являются источником шума в данных, который может негативно повлиять на качество модели. Кроме того, когда мы разобьем наш набор данных на обучающую и контрольную выборки, может оказаться, что данная категория отсутствует в обучающей выборке, но присутствует в контрольной выборке. Это вызовет проблемы при моделировании.</p>
<p>Регрессионная модель, встретив в новых данных наблюдение с неизвестной категорией предиктора, не сможет вычислить прогноз, потому что необходимый для прогноза регрессионный коэффициент по этой категории предиктора будет отсутствовать. Допустим, у нас есть новые данные, и одно из наблюдений имеет по переменной <code>pay</code> категорию <code>CD</code>, которой не было в обучающей выборке. Тогда функция <code>predict()</code>, применяющая модель логистической регрессии к новым данным, вернет ошибку <em>«factor pay has new level(s)»</em>. Модель дерева проверит соответствие условиям, записанным в правилах классификации, и попытается выдать прогноз. Если соответствие не будет найдено, функция <code>predict()</code> пакета <code>CHAID</code> или <code>rpart</code> вернет ошибку <em>«factor pay has new level(s)»</em>, а функция <code>predict()</code> пакета <code>randomForest</code> – ошибку <em>«new factor levels not present in the training data»</em>. Поэтому на этапе предварительной обработки должна осуществляться обработка редких категорий.</p>
<p>В пакетах <code>ranger</code> и <code>h2o</code>, специально разработанных для работы с высокоразмерными данными (включая категориальные предикторы с высокой кардинальностью), редкие обычно категории не представляют проблемы.
Обработка редких категорий выполняется либо до разбиения на обучающую и контрольную выборки, либо после него в зависимости от причин, обусловивших появление таких категорий. Если переменная содержит 2-3 редких категорий небольшой частоты, скорее всего, такие категории случайны и могли быть обусловлены ошибками ввода. В нашем примере у переменной <code>pay</code> есть категория <code>CC</code>, встречающаяся 2554 раза, и категория <code>CD</code>, которая встречается 2 раза, поэтому, вероятно, речь идет об ошибке ввода. В таком случае эти категории, как правило, объединяют с самой часто встречающейся категорией (или объединяют в новую категорию). Это можно сделать как до разбиения на обучение и контроль, так и после него. Если переменная содержит множество категорий небольшой частоты, нам необходимо задать порог укрупнения – минимальное количество наблюдений в категории, ниже которого категория объявляется редкой. Поэтому для объективности решение о выборе такого порога должно приниматься уже после разбиения на обучающую и контрольную выборки. В противном случае получится, что решение о выборе порога мы принимали с учетом информации «из будущего». Такие редкие категории часто либо объединяют в одну отдельную категорию, либо объединяют с уже существующими категориями по результатам, полученным с помощью метода CHAID.</p>
<p>Итак, объединим редкую категорию <code>CD</code> с самой часто встречающейся категорией <code>СС</code>. Для этого воспользуемся функцией <code>recode()</code> пакета <code>car</code>. Удобство работы с ней заключается в том, что перед выполнением операций с уровнями не нужно преобразовывать фактор в символьный вектор, а после выполнения операций обратно преобразовывать символьный вектор в фактор.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="ch2.html#cb41-1"></a>dt[, pay <span class="op">:</span><span class="er">=</span><span class="st"> </span>car<span class="op">::</span><span class="kw">recode</span>(pay, <span class="st">&quot;&#39;CD&#39;=&#39;CC&#39;&quot;</span>)]</span></code></pre></div>
<p><em>СОВЕТ</em></p>
<p>С помощью функции <code>car::recode()</code> очень удобно выполнять перегруппировку категорий. Допустим, у нас есть переменная <code>var</code> с 5 категориями: <code>SCH</code>, <code>UGR</code>, <code>GRD</code>, <code>PGR</code>, <code>ACD</code>. Мы можем сформировать переменную с 3 категориями: <code>SCH</code>, <code>PGR</code> и <code>ACD</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="ch2.html#cb42-1"></a>var &lt;-<span class="st"> </span><span class="kw">recode</span>(var, </span>
<span id="cb42-2"><a href="ch2.html#cb42-2"></a>              <span class="st">&quot;&#39;SCH&#39;=&#39;SCH&#39;; </span></span>
<span id="cb42-3"><a href="ch2.html#cb42-3"></a><span class="st">               &#39;UGR&#39;=&#39;SCH&#39;; </span></span>
<span id="cb42-4"><a href="ch2.html#cb42-4"></a><span class="st">               &#39;GRD&#39;=&#39;PGR&#39;; </span></span>
<span id="cb42-5"><a href="ch2.html#cb42-5"></a><span class="st">               &#39;PGR&#39;=&#39;PGR&#39;; </span></span>
<span id="cb42-6"><a href="ch2.html#cb42-6"></a><span class="st">               &#39;ACD&#39;=&#39;ACD&#39;&quot;</span>)</span></code></pre></div>
<p>Снова выводим информацию о распределении значений переменной <code>pay</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="ch2.html#cb43-1"></a><span class="kw">summary</span>(dt<span class="op">$</span>pay)</span></code></pre></div>
<pre><code>## Auto   CC   CH NA&#39;s 
##  889 2556  977    2</code></pre>
<p>Видим, что теперь категория <code>CD</code> отсутствует, т.к. она была объединена с категорией <code>CC</code>.</p>
<p><em>СОВЕТ</em></p>
<p>Укрупнение редких категорий часто позволяет немного повысить качество модели. В ряде случаев более оптимальной стратегией может оказаться не объединение редко встречающихся категорий с наиболее часто встречающейся, а выделение редких категорий в отдельную группу. Например, у нас есть переменная <code>var</code>. и у нее редкими являются категории 5, 7, 9 и 12. Мы можем записать эти редкие категории в отдельную категорию <code>OTHER</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="ch2.html#cb45-1"></a>var &lt;-<span class="st"> </span><span class="kw">recode</span>(var, <span class="st">&quot;c(&#39;5&#39;, &#39;7&#39;,&#39;9&#39;, &#39;12&#39;) = &#39;OTHER&#39;&quot;</span>)</span></code></pre></div>
<p>Выведем информацию обо всех переменных в нашей таблице после всех выполненных преобразований. На этот раз воспользуемся функцией <code>skim()</code> из пакета <code>skimr</code> (подробнее об этом пакете можно прочитать <a href="https://ropensci.org/blog/2019/10/29/skimrv2/">здесь</a>):</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="ch2.html#cb46-1"></a><span class="co"># devtools::install_github(&quot;ropensci/skimr&quot;)</span></span>
<span id="cb46-2"><a href="ch2.html#cb46-2"></a></span>
<span id="cb46-3"><a href="ch2.html#cb46-3"></a>skimr<span class="op">::</span><span class="kw">skim</span>(dt)</span></code></pre></div>
<table>
<caption><span id="tab:unnamed-chunk-31">Table 2.1: </span>Data summary</caption>
<tbody>
<tr class="odd">
<td align="left">Name</td>
<td align="left">dt</td>
</tr>
<tr class="even">
<td align="left">Number of rows</td>
<td align="left">4424</td>
</tr>
<tr class="odd">
<td align="left">Number of columns</td>
<td align="left">10</td>
</tr>
<tr class="even">
<td align="left">_______________________</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Column type frequency:</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">factor</td>
<td align="left">9</td>
</tr>
<tr class="odd">
<td align="left">numeric</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">________________________</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">Group variables</td>
<td align="left">None</td>
</tr>
</tbody>
</table>
<p><strong>Variable type: factor</strong></p>
<table>
<thead>
<tr class="header">
<th align="left">skim_variable</th>
<th align="right">n_missing</th>
<th align="right">complete_rate</th>
<th align="left">ordered</th>
<th align="right">n_unique</th>
<th align="left">top_counts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">longdist</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="left">TRUE</td>
<td align="right">5</td>
<td align="left">15-: 1054, 9-1: 993, 2-8: 867, 21+: 771</td>
</tr>
<tr class="even">
<td align="left">local</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">TRUE</td>
<td align="right">5</td>
<td align="left">21-: 1444, 8-2: 763, 56+: 740, &lt;8: 738</td>
</tr>
<tr class="odd">
<td align="left">int_disc</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">FALSE</td>
<td align="right">2</td>
<td align="left">Нет: 3047, Да: 1376</td>
</tr>
<tr class="even">
<td align="left">billtype</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="left">FALSE</td>
<td align="right">2</td>
<td align="left">Бюд: 2241, Бес: 2181</td>
</tr>
<tr class="odd">
<td align="left">pay</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="left">FALSE</td>
<td align="right">3</td>
<td align="left">CC: 2556, CH: 977, Aut: 889</td>
</tr>
<tr class="even">
<td align="left">gender</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">FALSE</td>
<td align="right">2</td>
<td align="left">Жен: 2239, Муж: 2184</td>
</tr>
<tr class="odd">
<td align="left">marital</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">FALSE</td>
<td align="right">2</td>
<td align="left">Жен: 2624, Оди: 1799</td>
</tr>
<tr class="even">
<td align="left">agecat</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="left">TRUE</td>
<td align="right">5</td>
<td align="left">31-: 1303, 46-: 908, &lt;31: 755, 71+: 740</td>
</tr>
<tr class="odd">
<td align="left">churn</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="left">FALSE</td>
<td align="right">2</td>
<td align="left">Ост: 2492, Ухо: 1932</td>
</tr>
</tbody>
</table>
<p><strong>Variable type: numeric</strong></p>
<table>
<thead>
<tr class="header">
<th align="left">skim_variable</th>
<th align="right">n_missing</th>
<th align="right">complete_rate</th>
<th align="right">mean</th>
<th align="right">sd</th>
<th align="right">p0</th>
<th align="right">p25</th>
<th align="right">p50</th>
<th align="right">p75</th>
<th align="right">p100</th>
<th align="left">hist</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">income</td>
<td align="right">4</td>
<td align="right">1</td>
<td align="right">50297.04</td>
<td align="right">28440.28</td>
<td align="right">110.28</td>
<td align="right">25445.6</td>
<td align="right">50290.7</td>
<td align="right">75004.5</td>
<td align="right">99832.9</td>
<td align="left">▇▇▇▇▇</td>
</tr>
</tbody>
</table>
</div>
<div id="ch2.2.8" class="section level3" number="2.2.8">
<h3><span class="header-section-number">2.2.8</span> Однократное случайное разбиение набора данных на обучающую и контрольную выборки для проверки модели</h3>
<p>В прогнозном моделировании нам важно построить модель на обучающих данных, а затем получить точные прогнозы для новых, еще не встречавшихся данных, состоящих из тех же самых предикторов, что и использованный нами обучающий набор. Если модель может выдавать точные прогнозы на ранее не встречавшихся данных, можно сказать, что модель обладает способностью <em>обобщать</em> результат на новые данные. Нам требуется построить модель с максимальной <em>обобщающей способностью</em> (<em>generalization</em>).</p>
<p>Обычно цель специалиста по машинному обучению сводится к тому, чтобы модель давала точные прогнозы на обучающем наборе. Если обучающий набор и новые данные имеют много общего между собой, можно ожидать, что модель будет точно прогнозировать новые данные. Однако в ряде случаев на новых данных модель работает существенно хуже. Почему так происходит?</p>
<p>Проблема заключается в том, что на этапе подготовки данных часто отсутствует априорная информация о полезности тех или иных предикторов. Избыточное включение предикторов, не несущих новой информации, ведет к тому, что модель становится слишком сложной. Она слишком точно подстраивается под особенности обучающего набора, улавливает не только фактические взаимосвязи, но и случайные возмущения обучающих данных. По сути такая модель восстанавливает не только искомую зависимость, но и выполняет подгонку конкретных наблюдений. В итоге мы получаем модель, которая идеально работает на обучающем наборе, но плохо обобщает результат на новые данные, поскольку описывает случайный шум в данных, который не имеет ничего общего с истинной формой связи между зависимой переменной и предикторами. Такую ситуацию называют <em>переобучением</em> (<em>overfitting</em>). С другой стороны, включение недостаточного числа полезных признаков, наоборот, приводит к тому, что модель не может в достаточной мере уловить фактические зависимости, и качество модели даже на обучающей выборке остается довольно низким. Такую ситуацию называют <em>недообучением</em> (<em>underfitting</em>).</p>
<p>Для борьбы с описанными ситуациями необходимо настраивать сложность модели и проверять обобщающую способность, используя контрольную выборку. Существует оптимальная точка, которая позволяет получить наилучшую обобщающую способность. Собственно это и есть модель, которую нам нужно найти.</p>
<p>Выбор сложности модели – это компромисс между смещением и дисперсией. Недостаточно сложная модель не может быть достаточно гибкой, и это может привести к недообучению, пропуску взаимосвязей в данных (модель характеризуется высоким смещением). Неопытный исследователь может предположить, что наиболее сложная модель должна всегда лучше предсказывать, но это не так. Слишком сложная модель является слишком гибкой, что ведет к переобучению, учету случайного шума выборки (модель характеризуется высокой дисперсией). У моделей с низким смещением высока дисперсия, и наоборот. В современных методах машинного обучения мы чаще всего регулируем сложность через отбор признаков: обращение коэффициентов точно в ноль с помощью методов регуляризации в регрессионных моделях, случайный отбор признаков и прунинг в случайном лесе и градиентном бустинге, <a href="https://habr.com/ru/company/wunderfund/blog/330814/">дропаут</a> в нейронных сетях.</p>
<p>Наиболее распространенными методами проверки являются: однократное случайное разбиение набора данных на обучающую и контрольную выборки; однократное случайное разбиение набора данных на обучающую, проверочную/валидационную и контрольную/тестовую выборки; различные варианты перекрестной проверки (кросс-валидация), обычно также с резервированием тестовой выборки для итоговой оценки качества.</p>
<p>Мы начнем с однократного случайного разбиения на обучающую и контрольную выборки. При таком способе проверки модель строится на обучающей выборке, а ее качество проверяется на контрольной выборке (рис. 2.9). Очевидно, что описанный подход является корректным только в том случае, если на основании оценки качества на контрольной выборке не производится выбор лучшей модели из множества альтернатив. В противном случае можно получить завышенные оценки качества, т.е. может произойти косвенное переобучение на контрольную выборку.</p>
<p><img src="figures/2.9.PNG" /></p>
<p><em>Риc. 2.9. Схема разделения выборки на обучающую и контрольную</em></p>
<p>Давайте случайным образом разобьем нашу таблицу <code>dt</code> на обучающий набор данных <code>development</code> и контрольный набор данных <code>holdout</code>. Примерно 70% наблюдений исходного набора попадут в обучающую выборку, а 30% наблюдений – в контрольную выборку. Поскольку разбиение осуществляется случайным образом, необходимо задать стартовое значение генератора случайных чисел для воспроизводимости полученных результатов:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="ch2.html#cb47-1"></a><span class="kw">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb47-2"><a href="ch2.html#cb47-2"></a>train_rows &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>dt[, .N], dt[, .N] <span class="op">*</span><span class="st"> </span><span class="fl">0.7</span>)</span>
<span id="cb47-3"><a href="ch2.html#cb47-3"></a>development &lt;-<span class="st"> </span>dt[train_rows, ]</span>
<span id="cb47-4"><a href="ch2.html#cb47-4"></a>holdout &lt;-<span class="st"> </span>dt[<span class="op">-</span>train_rows, ]</span>
<span id="cb47-5"><a href="ch2.html#cb47-5"></a></span>
<span id="cb47-6"><a href="ch2.html#cb47-6"></a><span class="kw">str</span>(development)</span></code></pre></div>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:	3096 obs. of  10 variables:
##  $ longdist: Ord.factor w/ 5 levels &quot;&lt;2&quot;&lt;&quot;2-8&quot;&lt;&quot;9-14&quot;&lt;..: 4 4 2 4 5 5 5 3 1 5 ...
##  $ local   : Ord.factor w/ 5 levels &quot;&lt;8&quot;&lt;&quot;8-20&quot;&lt;&quot;21-35&quot;&lt;..: 4 3 4 2 2 1 3 3 1 3 ...
##  $ int_disc: Factor w/ 2 levels &quot;Да&quot;,&quot;Нет&quot;: 2 2 1 2 2 2 2 1 1 2 ...
##  $ billtype: Factor w/ 2 levels &quot;Бесплатный&quot;,&quot;Бюджетный&quot;: 1 1 1 1 2 1 2 2 1 2 ...
##  $ pay     : Factor w/ 3 levels &quot;Auto&quot;,&quot;CC&quot;,&quot;CH&quot;: 2 2 1 2 3 2 2 2 2 3 ...
##  $ gender  : Factor w/ 2 levels &quot;Женский&quot;,&quot;Мужской&quot;: 2 1 2 1 1 1 2 2 2 1 ...
##  $ marital : Factor w/ 2 levels &quot;Женат&quot;,&quot;Одинокий&quot;: 1 1 1 1 1 1 2 1 1 2 ...
##  $ income  : num  11890 50291 68828 85048 1415 ...
##  $ agecat  : Ord.factor w/ 5 levels &quot;&lt;31&quot;&lt;&quot;31-45&quot;&lt;..: 3 2 4 3 5 1 3 1 5 1 ...
##  $ churn   : Factor w/ 2 levels &quot;Остается&quot;,&quot;Уходит&quot;: 1 1 1 2 2 1 1 1 1 1 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="ch2.html#cb49-1"></a><span class="kw">str</span>(holdout)</span></code></pre></div>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:	1328 obs. of  10 variables:
##  $ longdist: Ord.factor w/ 5 levels &quot;&lt;2&quot;&lt;&quot;2-8&quot;&lt;&quot;9-14&quot;&lt;..: 1 NA 1 1 1 1 1 1 1 1 ...
##  $ local   : Ord.factor w/ 5 levels &quot;&lt;8&quot;&lt;&quot;8-20&quot;&lt;&quot;21-35&quot;&lt;..: NA 1 1 1 1 1 1 1 1 1 ...
##  $ int_disc: Factor w/ 2 levels &quot;Да&quot;,&quot;Нет&quot;: 2 2 2 2 2 2 2 2 1 2 ...
##  $ billtype: Factor w/ 2 levels &quot;Бесплатный&quot;,&quot;Бюджетный&quot;: 1 1 1 2 1 1 2 2 2 1 ...
##  $ pay     : Factor w/ 3 levels &quot;Auto&quot;,&quot;CC&quot;,&quot;CH&quot;: 1 NA 3 2 2 2 2 2 2 1 ...
##  $ gender  : Factor w/ 2 levels &quot;Женский&quot;,&quot;Мужской&quot;: NA 1 2 1 1 2 2 2 1 2 ...
##  $ marital : Factor w/ 2 levels &quot;Женат&quot;,&quot;Одинокий&quot;: 2 2 2 1 2 1 1 1 1 2 ...
##  $ income  : num  16830 57273 18831 34806 47212 ...
##  $ agecat  : Ord.factor w/ 5 levels &quot;&lt;31&quot;&lt;&quot;31-45&quot;&lt;..: 1 1 1 1 2 2 3 3 3 3 ...
##  $ churn   : Factor w/ 2 levels &quot;Остается&quot;,&quot;Уходит&quot;: 2 2 1 2 2 2 2 2 2 1 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Мы могли бы уже начать строить модель, а потом проверять ее, но сперва нужно ответить на вопрос, достаточен ли объем обучающей и контрольной выборки для построения и проверки модели?</p>
<p>В практике банковского скоринга для ответа на поставленный вопрос часто используют правило «Number of Events Per Variable» (количество событий на одну переменную, NEPV), сформулированное Фрэнком Харреллом. Для задачи классификации оно связывает минимальный объем выборки с количеством «событий» – наблюдений в миноритарной (наименьшей по размеру) категории зависимой переменной и количеством предикторов, поданным на вход модели. Согласно этому правилу, необходимо взять количество наблюдений в обучающей выборке, относящихся к миноритарной категории зависимой переменной (в кредитном скоринге это «плохие» заемщики). Это число наблюдений нужно разделить на количество заданных предикторов. Для регрессионной модели на один предиктор должно приходиться не менее 20 событий, при построении дерева решений CHAID<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> на один предиктор должно приходиться не менее 50 событий, а для модели случайного леса, градиентного бустинга, SVM и нейронной сети на одну независимую переменную должно приходиться не менее 200 событий. Для задачи регрессии мы просто берем количество наблюдений и делим на количество предикторов и для регрессионной модели на одну независимую переменную должно приходиться не менее 20 наблюдений, для дерева решений CHAID (в тех случаях, когда реализация алгоритма позволяет решать задачу регрессии) на один предиктор должно приходиться не менее 50 наблюдений, для случайного леса и других сложных моделей на один предиктор должно приходиться не менее 200 наблюдений.</p>
</div>
</div>
</div>

<div class="footnotes">
<hr />
<ol start="6">
<li id="fn6"><p>Если предиктор имеет одну категорию, он исключается из анализа. Если предиктор имеет две категории, происходит переход к шагу 3.<a href="ch2.html#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>По мнению Фрэнка Харрелла, для дерева рещений CART правило NEPV невозможно сформулировать из-за высокой нестабильности метода и склонности к переобучению.<a href="ch2.html#fnref7" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="ch1.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="ch3.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
